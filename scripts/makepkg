#!/bin/bash
#
#   makepkg
#
#   Copyright (c) 2005 by Aurelien Foret <orelien@chez.com>
#   Copyright (c) 2005 by Judd Vinet <jvinet@zeroflux.org>
#   Copyright (c) 2005 by Christian Hamar <krics@linuxforum.hu>
#   Copyright (c) 2006 by Alex Smith <alex@alex-smith.me.uk>
#   Copyright (c) 2006 by Andras Voroskoi <voroskoi@frugalware.org>
#   Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010 by Miklos Vajna <vmiklos@frugalware.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#   USA.
#

umask 0022

## bash's 'echo' is buggy and does not check on write() for errors
ECHO="/bin/echo"
startdir=`pwd`

# compat functions. these are useful if one would like to use makepkg outside
# FST. if you want to modify these, please submit a patch again FST first

###
# * Fextract(): Extract archives. Parameter: file name to extract. Example:
# Fextract pacman.tar.gz.
###
Fextract() {
	local cmd file tmp
	file="${1}"
	tmp="$($ECHO "${file}" | tr 'A-Z' 'a-z')"
	case "${tmp}" in
		*.tar.bz2|*.tbz2)
		cmd="tar $_F_extract_taropts --use-compress-program=bzip2 -xf $file" ;;
		*.tar.gz|*.tar.z|*.tgz)
		cmd="tar $_F_extract_taropts --use-compress-program=gzip -xf $file" ;;
		*.tar.lzma)
		cmd="tar $_F_extract_taropts --use-compress-program=lzma -xf $file" ;;
		*.tar.xz)
		cmd="tar $_F_extract_taropts --use-compress-program=xz -xf $file" ;;
		*.tar)
		cmd="tar $_F_extract_taropts -xf $file" ;;
		*.zip|*.xpi)
		unziphack=1
		cmd="unzip -qqo $file" ;;
		*.cpio.gz)
		cmd="bsdtar -x -f $file" ;;
		*.cpio.bz2)
		cmd="bsdtar -x -f $file" ;;
		*.gz)
		cmd="gunzip -f $file" ;;
		*.bz2)
		cmd="bunzip2 -f $file" ;;
		*.lzma)
		cmd="unlzma -f $file" ;;
		*.xz)
		cmd="unxz -f $file" ;;
		*.7z)
		cmd="7z x $file" ;;
		*)
		cmd="" ;;
	esac
	if [ "$cmd" != "" ]; then
		msg2 "$cmd"
		$cmd
		ret=$?
		if [ $ret -ne 0 ]; then
			# unzip will return a 1 as a warning, it is not an error
			if [ "$unziphack" != "1" -o $ret -ne 1 ]; then
				error "Failed to extract ${file}"
				msg "Aborting..."
				Fdie
			fi
		fi
	fi
}

# Frugalware extensions to makepkg
[ -e /usr/lib/frugalware/fwmakepkg ] && . /usr/lib/frugalware/fwmakepkg

### SUBROUTINES ###

plain() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "    \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "    $1" >&2
	fi
}
msg() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;32m==>\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> $1" >&2
	fi
}

msg2() {
        if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
                $ECHO -e "   \033[1;34m->\033[1;0m \033[1;1m$1\033[1;0m" >&2
        else
                $ECHO "   -> $1" >&2
        fi
}

warning() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;33m==> WARNING:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> WARNING: $1" >&2
	fi
}
error() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		$ECHO -e "\033[1;31m==> ERROR:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		$ECHO "==> ERROR: $1" >&2
	fi
}

strip_url() {
	$ECHO "$1" | sed 's|^.*://.*/||g'
}

find_executable() {
	local executable="$1"
	shift

	if ! type -p "$executable" &>/dev/null; then
		warning "\"$executable\" was not found in PATH. $@"
		return 1
	fi
	return 0
}

# FIXME: allow to output long format ? "1 hour 55 minutes 1 second"
seconds_to_human_duration() {
	local hours minutes seconds time

	hours="$(( $1 / 3600 ))"
	minutes="$(( $1 % 3600 / 60 ))"
	seconds="$(( $1 % 3600 % 60 ))"

	if [ "$hours" -gt 0 ]; then
		time+=" ${hours}h"
	fi
	if [ "$minutes" -gt 0 ]; then
		time+=" ${minutes}m"
	fi
	if [ "$seconds" -gt 0 ]; then
		time+=" ${seconds}s"
	fi
	echo "$time"
}

checkdeps() {
	local deplist="" missdep="" ret

	[ $# -gt 0 ] || return

	missdep="$($PACMAN $PACMAN_OPTS -T "$@")"
	ret=$?
	if [ "$ret" != "0" ]; then
		if [ "$ret" = "127" ]; then
			msg "Missing Dependencies:"
			msg ""
			nl=0
			for dep in $missdep; do
				$ECHO -ne "$dep " >&2
				if [ "$nl" = "1" ]; then
					nl=0
					$ECHO -ne "\n" >&2
					# add this dep to the list
					depname=`$ECHO $dep | sed 's|=.*$||' | sed 's|>.*$||' | sed 's|<.*$||'`
					deplist="$deplist $depname"
					continue
				fi
				nl=1
			done
			msg ""
		else
			error "$PACMAN returned a fatal error."
			exit 1
		fi
	fi
	$ECHO $deplist
}

handledeps() {
	local missingdeps=0
	local deplist="$*"
	local haveperm=0
	if [ \( "`id -u`" = "0" -a "$INFAKEROOT" != "1" \) -o "$DEP_SUDO" = 1 ]; then
		haveperm=1
	fi

	if [ "$deplist" != "" -a $haveperm -eq 1 ]; then
		if [ "$DEP_BIN" = "1" ]; then
			# install missing deps from binary packages (using pacman-g2 -S)
			msg "Installing missing dependencies..."
			if [ "$INCHROOT" != "1" -o "`check_option SCRIPTLET`" ]; then
				$SUDO $PACMAN $PACMAN_OPTS -D $deplist
			else
				$SUDO $PACMAN $PACMAN_OPTS --noscriptlet -D $deplist
			fi
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
		elif [ "$DEP_SRC" = "1" ]; then
			# install missing deps by building them from source.
			# we look for each package name in $fst_root and build it.
			# TODO: handle version comparators (eg, glibc>=2.2.5)
			msg "Building missing dependencies..."
			for dep in $deplist; do
				candidates=`find $fst_root -type d -name "$dep"`
				if [ "$candidates" = "" ]; then
					error "Could not find \"$dep\" under $fst_root"
					exit 1
				fi
				success=0
				for pkgdir in $candidates; do
					if [ -f $pkgdir/$BUILDSCRIPT ]; then
						cd $pkgdir
						if [ "$RMDEPS" -eq 1 ]; then
							makepkg -i -c -b -r -w "$PKGDEST"
						else
							makepkg -i -c -b -w "$PKGDEST"
						fi
						if [ $? -eq 0 ]; then
							success=1
							break
						fi
					fi
				done
				if [ "$success" = "0" ]; then
					error "Failed to build \"$dep\""
					exit 1
				fi
			done
		else
			missingdeps=1
		fi
	elif [ "$deplist" != "" -a $haveperm -eq 0 ]; then
		if [ "$DEP_SRC" = "1" -o "$DEP_BIN" = "1" ]; then
			warning "Cannot auto-install missing dependencies as a normal user without sudo!"
			plain "Run makepkg as root or with -S to resolve dependencies automatically."
		fi
		missingdeps=1
	fi
	# rerun any additional sh scripts found in /etc/profile.d/
	for i in /etc/profile.d/*.sh; do
		if [ -x $i ]; then
			. $i &>/dev/null
		fi
	done
	return $missingdeps
}

chroot_lock() {
	if [ -e $CHROOTDIR/var/tmp/fst/lock -a -d /proc/$(cat $CHROOTDIR/var/tmp/fst/lock 2>/dev/null) ]; then
		error "Process $(cat $CHROOTDIR/var/tmp/fst/lock) is already building in this chroot."
		plain "If you know what you are doing, you"
		plain "can remove $CHROOTDIR/var/tmp/fst/lock."
		exit 1
	else
		echo $$ >$CHROOTDIR/var/tmp/fst/lock
	fi
}

chroot_unlock() {
	rm -f $CHROOTDIR/var/tmp/fst/lock $_F_makepkg_pacconf
}

chroot_mount() {
    msg "Attempting to mount chroot directories..."
    mount -t proc none $CHROOTDIR/proc >/dev/null
    mount -t sysfs none $CHROOTDIR/sys >/dev/null
    mount -t devtmpfs none $CHROOTDIR/dev >/dev/null
    mount -o bind /var/cache/pacman-g2 $CHROOTDIR/var/cache/pacman-g2 >/dev/null
    mount -o bind $CCACHE_BASEDIR/$pkgname \
    $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to mount chroot directories."
	exit 1
    fi
    msg "Successfully mounted chroot directories."
}

chroot_umount() {
    msg "Attempting to umount chroot directories..."
    umount $CHROOTDIR/proc >/dev/null
    umount $CHROOTDIR/sys >/dev/null
    umount $CHROOTDIR/dev >/dev/null
    umount $CHROOTDIR/var/cache/pacman-g2 >/dev/null
    umount $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to umount chroot directories."
	exit 1
    fi
    msg "Successfully umounted chroot directories."
}

chroot_size() {
	exclude="--exclude=/proc --exclude=/sys --exclude=/dev"
	exclude="$exclude --exclude=/var/cache/pacman-g2 --exclude=/var/cache/ccache/$pkgname"
	sudo du -sh $exclude / |sed "s/\t.*//"
}

chroot_clean()
{
	if [ "$CHROOT" = "1" ]; then
		$ECHO $CHROOTDIR |grep -q $TREE$ || CHROOTDIR="$CHROOTDIR/$TREE"
		if [ -d "$CHROOTDIR" ]; then
			chroot_lock
			msg "Removing unnecessary packages."
			for i in "$COREPKGS"
			do
				corelist="$corelist `/usr/sbin/chroot $CHROOTDIR $PACMAN -Sg $i |grep -v '^\w'`"
			done
			for i in `/usr/sbin/chroot $CHROOTDIR $PACMAN -Q|sed 's/\([^ ]*\) .*/\1/'`
			do
				if ! $ECHO $corelist |grep -qw $i; then
					removelist="$removelist $i"
				fi
			done
			if [ ! -z "$removelist" ]; then
				/usr/sbin/chroot $CHROOTDIR $PACMAN -Rcn $removelist --noconfirm
				if [ "$?" != "0" ]; then
					error "Failed to remove packages."
					exit 1
				fi
			fi
			msg "Cleaning chroot."
			rm -rf $CHROOTDIR/var/tmp/fst/*
		else
			error "$CHROOTDIR does not exist, can't clean a non-existing chroot."
			exit 1
		fi
	fi
}

chroot_enter() {
	if [ "$CHROOT" -ne 1 -o "$INCHROOT" -eq 1 ]; then
		return 0
	fi
	if [ "`id -u`" != 0 ]; then
		error "Building in a chroot as an unprivileged user is not possible."
		exit 1
	fi
	if [ "$CHROOTDIR" = "" ]; then
		error "The CHROOTDIR environment variable is not defined."
		exit 1
	fi
	CHROOTDIR="$CHROOTDIR/$TREE"

	mkdir -p $CHROOTDIR/{dev,etc,proc,sys,var/cache/pacman-g2,var/tmp/fst}

	chroot_lock

	install -d -m 2775 {$CCACHE_BASEDIR,$CHROOTDIR/var/cache/ccache}/$pkgname

	chroot_mount

	if [ ! -d "$CHROOTDIR/usr" -o ! -e "$CHROOTDIR/etc/pacman-g2.conf" ]; then
		msg "Building a '-$TREE' chroot environment"
		_F_makepkg_pacconf=`mktemp`
		cat /etc/pacman-g2.conf |grep -v Include >$_F_makepkg_pacconf
		for i in `$ECHO $TREE|sed 's/,/ /g'`
		do
			repo=$(eval "$ECHO \${${i}_$DB_EXT/.$DB_EXT}")
			[ -z "$repo" ] && repo="$i"
			# the config parser doesn't know about -r, so we
			# need $CHROOTDIR here for this first run
			$ECHO "Include = $CHROOTDIR/etc/pacman-g2/repos/$repo" >>$_F_makepkg_pacconf
		done
		mkdir -p $CHROOTDIR/{tmp,var/log,etc/pacman-g2/repos}
		cp -pf /etc/pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
		if [ -d ~/.pacman-g2/repos ]; then
			cp -pf ~/.pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
		fi
		$PACMAN -r "$CHROOTDIR" -Syf $COREPKGS --noconfirm --config $_F_makepkg_pacconf
		if [ "$?" != "0" ]; then
			error "Failed to build chroot environment."
			chroot_umount
			chroot_unlock
			exit 1
		fi
		cat $_F_makepkg_pacconf > $CHROOTDIR/etc/pacman-g2.conf
		# later runs use 'chroot pacman-g2' instead of
		# 'pacman-g2 -r', so get rid of $CHROOTDIR
		sed -i "s|$CHROOTDIR||" $CHROOTDIR/etc/pacman-g2.conf
		rm -f $_F_makepkg_pacconf
	else
		msg "Updating the '-$TREE' chroot environment"
		# copy these before any update since without them we can't even reach the servers
		cp -pf /etc/{resolv.conf,services} $CHROOTDIR/etc
		# run pacman-g2 -Su twice in case pacman-g2 updated
		yes "" | /usr/sbin/chroot "$CHROOTDIR" $PACMAN -Sy pacman-g2 --ask 94 && \
			/usr/sbin/chroot "$CHROOTDIR" $PACMAN -Su --noconfirm
		if [ "$?" != "0" ]; then
			error "Failed to update chroot environment."
			chroot_umount
			chroot_unlock
			exit 1
		fi
	fi
	# why is this necessary?
	chmod 1777 $CHROOTDIR/{var,}/tmp

	msg "Copying config files to chroot"
	cp -pf /etc/pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
	if [ -d ~/.pacman-g2/repos ]; then
		cp -pf ~/.pacman-g2/repos/* $CHROOTDIR/etc/pacman-g2/repos >/dev/null
	fi
	# mtab can be removed once Frugalware-1.4 is out
	for i in makepkg.conf resolv.conf passwd shadow group fstab mtab
	do
		if [ -h $CHROOTDIR/etc/$i ]; then
			# it's a symlink, don't touch it
			continue
		fi
		cp -pf /etc/$i $CHROOTDIR/etc >/dev/null
		if [ -e $HOME/.$i ]; then
			cp $HOME/.$i $CHROOTDIR/etc/$i >/dev/null
		fi
	done
	chmod 644 $CHROOTDIR/etc/sudoers
	$ECHO "fst ALL=(ALL)       NOPASSWD: ALL" >$CHROOTDIR/etc/sudoers
	chmod 440 $CHROOTDIR/etc/sudoers
	chmod 644 $CHROOTDIR/etc/pacman-g2.conf
	cp -Ppf /etc/localtime $CHROOTDIR/etc >/dev/null
	cp -pf /etc/services $CHROOTDIR/etc > /dev/null
	if [ "$?" != "0" ]; then
		error "An error occurred while attempting to copy config files to chroot."
		chroot_umount
		exit 1
	fi
	# to make Finclude work
	[ -d $CHROOTDIR/var/tmp/fst/include/ ] || mkdir -p $CHROOTDIR/var/tmp/fst/include/
	if [ -d $Fincdir ]; then
		cp $Fincdir/* $CHROOTDIR/var/tmp/fst/include/
	fi

	msg "Copying $pkgname's buildscript to chroot"
	cp -a * $CHROOTDIR/var/tmp/fst/
	chown -R fst:users $CHROOTDIR/var/tmp/fst

	if find_executable /usr/sbin/chroot; then
		msg "Entering chroot environment"
		BUILDLOG=${startdir}/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
		if [ ! "`check_option NOFAKEROOT`" ]; then
			# add the fst user in case the host system is not a Frugalware one
			if ! getent passwd fst >/dev/null; then
				echo "fst:x:19:2::/var/tmp/fst:" >> $CHROOTDIR/etc/passwd
			fi
			# add fst to the ccache group if necessary
			if ! getent group ccache|grep -q fst; then
				/usr/sbin/chroot $CHROOTDIR \
					/usr/sbin/usermod -a -G ccache fst
			fi
			/usr/sbin/chroot $CHROOTDIR /usr/sbin/pwconv
			/usr/sbin/chroot $CHROOTDIR \
				/bin/su - fst -c "fakeroot -- $0 -F --inchroot -S $ARGLIST"
		else
			$ECHO "cd /var/tmp/fst/; $0 --inchroot -s $ARGLIST" | \
				/usr/sbin/chroot $CHROOTDIR /bin/su - -c /bin/sh
		fi 2>&1 | tee $BUILDLOG
		if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
			# remove colors
			sed -i "s|.[1;[0-9]\+m||g" $BUILDLOG
		fi
	fi

	if [ "`id -u`" = "0" ]; then
		chown `stat -c %u:%g $BUILDSCRIPT` \
			${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
	fi

	if [ -f "$CHROOTDIR/var/tmp/fst/${_P_package_archives["${pkgname}"]}" ]; then
		mv $CHROOTDIR/var/tmp/fst/*-"${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT" "$PKGDEST"
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %u:%g $BUILDSCRIPT` \
				*-${pkgver}-${pkgrel}-${CARCH}.$PKG_EXT
		fi
		# copy back the buildscript, maybe modified
		cp $CHROOTDIR/var/tmp/fst/$BUILDSCRIPT ./
		if [ "$CLEANUP" != "1" ]; then
			mv $CHROOTDIR/var/tmp/fst/{pkg,src,pkg.*} ./ 2> /dev/null
			chown -R `stat -c %u:%g $BUILDSCRIPT` pkg src pkg.* 2> /dev/null
		fi
		rm -rf $CHROOTDIR/var/tmp/fst/*
		chroot_clean
		# check optimization and write it to $BUILDSCRIPT
		msg "Checking for optimization..."
		if grep -q -- "\($CFLAGS\|$CXXFLAGS\)" "${BUILDLOG}"; then
			if ! grep -q "# optimization" "${BUILDSCRIPT}"; then
				$ECHO -e "\n# optimization OK" >> "${BUILDSCRIPT}"
			fi
		else
			warning "This package isn't ${CARCH}-optimized!"
		fi
		# copy build log to LOGDIR if set
		if [ -d "$LOGDIR" ]; then
			msg "Creating permanent copy of build log"
			cp "${BUILDLOG}" "${LOGDIR}/${LOGDIR_APPEND}-${pkgname}-${pkgver}-${pkgrel}.log"
		fi
		ret=0
	else
		ret=1
	fi

	chroot_umount
	chroot_unlock
	exit $ret
}

# Enter the fakeroot environment if necessary.  This will call the makepkg script again
# as the fake root user.  We detect this by passing a sentinel option (-F) to makepkg
fakeroot_enter() {
	if [ "`id -u`" -eq 0 ]; then
		return 0
	fi

	if [ "$USE_FAKEROOT" = "y" -o "$USE_FAKEROOT" = "Y" ]; then
		if find_executable fakeroot; then
			msg "Entering fakeroot environment"
			if [ "$INCHROOT" != "1" ]; then
				fakeroot -- $0 -F $ARGLIST
			else
				fakeroot -- $0 -F --inchroot $ARGLIST
			fi
			exit $?
		else
			plain 'Building as an unprivileged user will result in non-root'
			plain 'ownership of the packaged files. Install the fakeroot package'
			plain 'to correctly build as a non-root user.'
			plain ''
			sleep 1
		fi
	else
		warning "Running makepkg as an unprivileged user will result in non-root"
		plain "ownership of the packaged files.  Try using the fakeroot"
		plain "environment.  (USE_FAKEROOT=y in makepkg.conf)"
		plain ""
		sleep 1
	fi
}

buildscript_download() {
	if [ -z "$DOWNLOAD" ]; then
		return 0
	fi

	msg "Retrieving $DOWNLOAD's buildscript..."

	# find the package
	if ! $PACMAN -Si "$DOWNLOAD" >/dev/null 2>&1; then
		error "Package \"$DOWNLOAD\" was not found."
		exit 1
	fi

	confs=`cat /etc/pacman-g2.conf |grep ^Include|sed 's/.* = \(.*\)/\1/'`

	# searching for a mirror
	repo=`$PACMAN -Si $DOWNLOAD |grep ^Repo |sed -n 's/.* \([^ ]*\)/\1/;1 p'`
	dir=`grep ^Server /etc/pacman-g2/repos/$repo |sed -n 's/.* = \(.*\)/\1/;1 p'`
	arch=`grep ^Server /etc/pacman-g2/repos/$repo |sed -n 's/.*-\(.*\)/\1/;1 p'`
	cat=`$PACMAN -Si $DOWNLOAD |grep ^G |sed 's/.* : \([^ ]*\) .*/\1/;'`
	dlpath="$dir/../"

	# download the script
	mkdir $DOWNLOAD
	cd $DOWNLOAD
	# FIXME: apps other than wget may not support -m and/or -l
	$FTPAGENT -m -l 1 $dlpath/source/$cat/$DOWNLOAD/ 2>&1
	if [ ! -f $file ]; then
		error "Failed to download $file"
		msg "Aborting..."
		exit 1
	fi
	junk=`$ECHO $dir|sed "s|^.*://\(.*\)/frugalware-$arch|\1/$quickdl|"`/source/$cat/$DOWNLOAD/
	mv $junk* ./
	rm -rf `$ECHO $junk|cut -d/ -f1`
	for i in `find * -type d`
	do
		( cd $i && [ -e .listing ] && rm .listing )
	done
}

buildscript_load() {
	if [ ! -f "$BUILDSCRIPT" ]; then
		error "$BUILDSCRIPT does not exist."
		exit 1
	fi

	local i

	unset pkgname pkgver pkgrel pkgdesc url license groups provides force
	unset replaces depends removes conflicts backup source install makedepends
	unset rodepends options pkdesc_localized
	for i in `set|grep ^_F_|sed 's/\(=.*\| ()\)//'`; do unset $i; done

	# You have to declare associative array before using them :/
	declare -Ag \
		_P_package_descriptions \
		_P_package_licenses \
		_P_package_replaces \
		_P_package_groups \
		_P_package_depends \
		_P_package_rodepends \
		_P_package_removes \
		_P_package_conflicts \
		_P_package_provides \
		_P_package_backups \
		_P_package_installs \
		_P_package_options \
		_P_package_archs \
		_P_package_archives

	source ./$BUILDSCRIPT

	if [ "`type -p fblint`" ]; then
		if ! fblint -p "$BUILDSCRIPT" &>/dev/null; then
			warning "fblint says some needed variables are missing or incomplete."
			plain "Abort the build unless you know what you are doing."
		fi
	fi

	if [ -z "$pkgver" ]; then
		error "pkgver is not allowed to be empty."
		exit 1
	fi
	if [ -z "$pkgrel" ]; then
		error "pkgrel is not allowed to be empty."
		exit 1
	fi
	if [ `$ECHO $pkgver | grep '-'` ]; then
		error "pkgver is not allowed to contain hyphens."
		exit 1
	fi
	if [ `$ECHO $pkgrel | grep '-'` ]; then
		error "pkgrel is not allowed to contain hyphens."
		exit 1
	fi
	if ! in_array $CARCH ${archs[@]}; then
		error "$pkgname is not available on $CARCH."
		exit 1
	fi

	if [ ! -z "$subpkgs" ]; then
		goodsubpkgs=1
		if [ "${#subdescs[@]}" != 0 ] && [ "${#subdescs[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subdescs_localized[@]}" != 0 ] && [ "${#subdescs_localized[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#sublicense[@]}" != 0 ] && [ "${#sublicense[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subreplaces[@]}" != 0 ] && [ "${#subreplaces[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subgroups[@]}" != 0 ] && [ "${#subgroups[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subdepends[@]}" != 0 ] && [ "${#subdepends[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subrodepends[@]}" != 0 ] && [ "${#subrodepends[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subremoves[@]}" != 0 ] && [ "${#subremoves[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subconflicts[@]}" != 0 ] && [ "${#subconflicts[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subprovides[@]}" != 0 ] && [ "${#subprovides[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subbackup[@]}" != 0 ] && [ "${#subbackup[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subinstall[@]}" != 0 ] && [ "${#subinstall[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#suboptions[@]}" != 0 ] && [ "${#suboptions[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ "${#subarchs[@]}" != 0 ] && [ "${#subarchs[@]}" != "${#subpkgs[@]}" ]; then
			goodsubpkgs=0
		fi
		if [ $goodsubpkgs -ne 1 ]; then
			error "Subpackage infos are incomplete. Cannot create subpackages."
			exit 1
		fi
	fi

	# Compatibility adaptation
	if [ "${#_P_package_names[@]}" -eq 0 ]; then
		_P_options="${options[*]}"

		_P_package_names=("${pkgname}" "${subpkgs[@]}")
		_P_package_descriptions["${pkgname}"]="${pkgdesc}"
		for i in "${pkgdesc_localized[@]}"; do
			_P_package_descriptions["${pkgname}"]+="$($ECHO -en "\n$i")"
		done
		_P_package_licenses["${pkgname}"]="${license[*]}"
		_P_package_replaces["${pkgname}"]="${replaces[*]}"
		_P_package_groups["${pkgname}"]="${groups[*]}"
		_P_package_depends["${pkgname}"]="${depends[*]}"
		_P_package_rodepends["${pkgname}"]="${rodepends[*]}"
		_P_package_removes["${pkgname}"]="${removes[*]}"
		_P_package_conflicts["${pkgname}"]="${conflicts[*]}"
		_P_package_provides["${pkgname}"]="${provides[*]}"
		_P_package_backups["${pkgname}"]="${backup[*]}"
		_P_package_installs["${pkgname}"]="${install}"
		_P_package_options["${pkgname}"]="${options[*]}"
		_P_package_archs["${pkgname}"]="${archs[*]}"

		i=0
		for subpkg in "${subpkgs[@]}"; do
			_P_package_descriptions["${subpkg}"]="$($ECHO -en "${subdescs[$i]}\n${subdescs_localized[$i]}")"
			_P_package_licenses["${subpkg}"]="${sublicense[$i]}"
			_P_package_replaces["${subpkg}"]="${subreplaces[$i]}"
			_P_package_groups["${subpkg}"]="${subgroups[$i]}"
			_P_package_depends["${subpkg}"]="${subdepends[$i]}"
			_P_package_rodepends["${subpkg}"]="${subrodepends[$i]}"
			_P_package_removes["${subpkg}"]="${subremoves[$i]}"
			_P_package_conflicts["${subpkg}"]="${subconflicts[$i]}"
			_P_package_provides["${subpkg}"]="${subprovides[$i]}"
			_P_package_backups["${subpkg}"]="${subbackup[$i]}"
			_P_package_installs["${subpkg}"]="${subinstall[$i]}"
			_P_package_options["${subpkg}"]="${suboptions[$i]}"
			_P_package_archs["${subpkg}"]="${subarchs[$i]}"
			i=$(($i+1))
		done
	fi

	# Check _P_package_names on your arch
	i=0
	while [ $i -lt ${#_P_package_names[@]} ]; do
		if in_array $CARCH ${_P_package_archs["${_P_package_names["$i"]}"]}; then
			_P_package_archives["${_P_package_names["$i"]}"]="${pkgname}-${pkgver}-${pkgrel}-${CARCH}.${PKG_EXT}"
			i=$(($i+1))
		else
			warning "Package ${_P_package_names["$i"]} is not available on your ARCH, dropping it!"
			unset _P_package_names["$i"]
		fi
	done

	local pkgname
	for pkgname in "${_P_package_names[@]}"; do
		if [ -n "$_P_package_installs["$pkgname"]" ]; then
			# FIXME we should allways be in startdir here
			if [ ! -e "$install" -a ! -e "$startdir/$install" ] && ! check_option GENSCRIPTLET; then
				error "Missing install scriptlet. If this is intentional, add 'genscriptlet' to options()."
				exit 1
			fi
		else
			if [ -e "${pkgname}.install" ]; then
				warning "Automagically found install script for $pkgname"
				_P_package_installs["$pkgname"]="${pkgname}.install"
			fi
		fi
	done
}

buildscript_up2date() {
	if [ "$NOUP2DATE" -eq 1 ]; then
		return 0
	fi

	msg "Checking for newer version..."
	if $ECHO "$up2date"|grep -q " "; then
		cmd=`$ECHO "$up2date"|sed 's/^\([^ ]*\) .*/\1/'`
		if find_executable "$cmd" 'Cannot check for newer version!'; then
			up2date=`eval "$up2date"`
		else
			up2date=""
			sleep 1
		fi
	fi
	if [ -z "$up2date" ]; then
			$ECHO "   FAILED" >&2
			error "There was no output!"
			exit 1
	else
		if [ "$pkgver" != "$up2date" ]; then
			$ECHO "   FAILED" >&2
			error "Upstream version differs! ($pkgver != $up2date)"
			exit 1
		else
		$ECHO "   Passed" >&2
		fi
	fi
}

buildscript_estimation () {
	# estimate build time
	if grep -i -q "^# Compiling Time: [~0-9\.]\+ SBU$" $BUILDSCRIPT && \
		[ ! -z "$SBU" ] && [ "$SBU" != "1" ]; then
		pkgsbu=`grep -i "^# Compiling time: [~0-9\.]\+ SBU$" $BUILDSCRIPT|sed 's/^# Compiling [Tt]ime: ~*\([0-9\.]\+\) SBU$/\1/'`
		if find_executable bc 'Cannot calculate the estimated build time!'; then
			secs=`$ECHO "$pkgsbu*$SBU"|bc /dev/stdin|sed 's/\.[0-9]*$//'`
			[ -z "$secs" ] && secs=0
			msg "Estimated build time:$(seconds_to_human_duration "$secs")"
		fi
	fi
}

buildscript_create_changelog() {
	local indir=n

	if [ "$F_makepkg_scm" = "git" ]; then
		git rev-parse --git-dir &>/dev/null && indir=y
	elif [ "$F_makepkg_scm" = "darcs" ]; then
		darcs --commands 2>&1|grep -q add && indir=y
	elif [ "$F_makepkg_scm" = "svn" ]; then
		svn info $BUILDSCRIPT &>/dev/null && indir=y
	fi
	if [ "$indir" = "y" ]; then
		if [ ! -e Changelog ] || [ `stat -c %Y Changelog|sed 's/\..*//'` -lt `stat -c %Y $BUILDSCRIPT|sed 's/\..*//'` ]; then
			msg "Generating the Changelog..."
			if [ "$F_makepkg_scm" = "git" ]; then
				git log $BUILDSCRIPT >Changelog
			elif [ "$F_makepkg_scm" = "darcs" ]; then
				darcs changes $BUILDSCRIPT | \
					sed "s|\(.*\)source/\(.*\)/$BUILDSCRIPT\(.*\)|\1\2\3|;/Can't find changes prior to:/,\$d" \
					>Changelog
			elif [ "$F_makepkg_scm" = "svn" ]; then
				svn log $BUILDSCRIPT >Changelog
			fi
			if [ "`id -u`" = "0" ]; then
				chown `stat -c %u:%g $BUILDSCRIPT` \
					Changelog
			fi
		fi
	fi
}

sources_download() {
	msg "Retrieving Sources..."
	mkdir -p src
	cd $startdir/src
	for netfile in "${source[@]}" "${signatures[@]}"; do
		[ -z "$netfile" ] && continue
		file=`strip_url "$netfile"`
		if [ -f "../$file" ]; then
			msg2 "Found $file in build dir"
			cp "../$file" .
		elif [ -f "/var/cache/pacman-g2/src/$file" ]; then
			msg2 "Using local copy of $file"
			cp "/var/cache/pacman-g2/src/$file" .
		else
			proto=`$ECHO "$netfile" | sed 's|://.*||'`
			if [ "$proto" != "ftp" -a "$proto" != "http" -a "$proto" != "https" ]; then
				error "$netfile was not found in the build directory and is not a proper URL."
				msg "Aborting..."
				exit 1
			fi
			# try to download the file from the cache server
			if [ -n "$RSYNCAGENT" -a -n "$CACHEURL" ]; then
				# check if the file is there
				eval $RSYNCAGENT $CACHEURL/${file//;/\\\;} &>/dev/null
				if [ "$?" = "0" ]; then
					eval $RSYNCAGENT $CACHEURL/${file//;/\\\;} ./
					if [ ! -f "$file" ]; then
						error "Failed to download $file from cache while it is there"
						msg "Aborting..."
						exit 1
					fi
				fi
			fi
			# if failed to retreive from cache download it from the master server
			if [ ! -f "$file" ]; then
				msg2 "Downloading $file"
				$FTPAGENT "$netfile" 2>&1
				if [ ! -f "$file" ]; then
					error "Failed to download $file"
					msg "Aborting..."
					exit 1
				fi
			fi
			if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
				mkdir -p /var/cache/pacman-g2/src && cp "$file" /var/cache/pacman-g2/src
			else
				cp "$file" ..
			fi
		fi
	done
}

sources_sha1sum_validate() {
	if [ ${#sha1sums[@]} -eq ${#source[@]} ]; then
		if find_executable sha1sum 'Cannot verify source files!'; then
			msg "Validating source files with SHA1sums"
			errors=0
			idx=0
			for netfile in "${source[@]}"; do
				file=`strip_url "$netfile"`
				$ECHO -n "    $file ... " >&2
				$ECHO "${sha1sums[$idx]}  $file" | sha1sum -c - >/dev/null 2>&1
				if [ $? -ne 0 ]; then
					$ECHO "FAILED" >&2
					errors=1
				else
					$ECHO "Passed" >&2
				fi
				idx=$(($idx+1))
			done
			if [ $errors -gt 0 ]; then
				error "One or more files did not pass the validity check!"
				exit 1
			fi
		fi
	fi
}

sources_sha1sum_generate() {
	if [ "$GENSHA1" -ne 1 ]; then
		return 0
	fi
	if [ ! `type -p sha1sum` ]; then
		error "Cannot find the sha1sum program."
		exit 1
	fi

	msg "Generating SHA1sums for source files"
	plain ""
	ct=0
	newline=0
	numsrc=${#source[@]}
	for netfile in ${source[@]}; do
		file=$(strip_url $netfile)
		sum=$(sha1sum $file | cut -d' ' -f 1)
		if [ $ct -eq 0 ]; then
			SHA1SUMS="sha1sums=("
		else
			SHA1SUMS="${SHA1SUMS}"
		fi
		SHA1SUMS="${SHA1SUMS}'${sum}'"
		ct=$(($ct+1))
		if [ $ct -eq $numsrc ]; then
			SHA1SUMS="${SHA1SUMS})"
		else
			# Don't be afraid but \\\n instead of \n coz of the \\ a little below
			# \\\n would give \n (printed) but \\\\\n will give \
			# and a new line carriage '\n' (i.e '\''\n')
			SHA1SUMS="${SHA1SUMS} \\\\\n          "
		fi
	done
	$ECHO -e "${SHA1SUMS}"
	plain ""
	if [ "${WRITESHA1}" = 1 ]; then
		cd ${startdir}
		if [ "`grep -c sha1sums= ${BUILDSCRIPT}`" -gt 1 ]; then
			error "${BUILDSCRIPT} contain more than one sha1sums, please update manually"
			exit 1
		fi
		if grep -q sha1sums= ${BUILDSCRIPT}; then
			msg "Updating \$sha1sums() in the $BUILDSCRIPT."
			# remove the sha1sum lines except the first and
			# the last one. hopefully the regexp is complex
			# enough that we won't remove something
			# unrelated
			sed "/\t\? \+'[a-z0-9]\{40\}' \?\\\\/d" -i $BUILDSCRIPT
			# doing this in one step causes sed hang. maybe this is a sed bug?
			sed -e :a -e "\$!N;s/sha1sums=(.*)/MAKEPKG_$$/;ta;P;D" -i $BUILDSCRIPT
			sed "s/MAKEPKG_$$/$SHA1SUMS/" -i $BUILDSCRIPT
		else
			warning "Initial \$sha1sums() array does not exist, Aborting..."
		fi
	fi
	exit 0
}

sources_gpg_validate() {
	if [ ${#signatures[@]} -eq ${#source[@]} ]; then
		if find_executable gpg 'Cannot verify source files!'; then
			if [ ! -d ~/.gnupg ]; then
				msg "Configuring gpg..."
				gpg --list-keys
				$ECHO "keyserver-options auto-key-retrieve" >>~/.gnupg/gpg.conf
			fi
			if [ -e $startdir/$pkgname.key ]; then
				msg "Importing $pkgname.key"
				gpg --import $startdir/$pkgname.key
			fi
			msg "Validating source files with gpg"
			errors=0
			idx=0
			for netfile in "${source[@]}"; do
				file=`strip_url "$netfile"`
				sig=`strip_url "${signatures[$idx]}"`
				$ECHO -n "    $file ... " >&2
				if [ ! -z "$sig" ]; then
					echo "$sig" | grep -q "^$file" >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						case $file in
							*.gz)  cmd='zcat'  ;;
							*.bz2) cmd='bzcat' ;;
							*.xz)  cmd='xzcat' ;;
						esac
					else
						cmd='cat'
					fi
					$cmd $file | gpg --batch --verify $sig - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						$ECHO "FAILED" >&2
						errors=1
					else
						$ECHO "Passed" >&2
					fi
				else
					$ECHO "Skipping" >&2
				fi
				idx=$(($idx+1))
			done
			if [ $errors -gt 0 ]; then
				error "One or more files did not pass the validity check!"
				exit 1
			fi
		fi
	fi
}

sources_extract() {
	if [ "$NOEXTRACT" -eq 1 ]; then
		warning "Skipping source extraction -- using existing src/ tree"
		return 0
	fi

	msg "Extracting Sources..."
	for netfile in "${source[@]}"; do
		unziphack=0
		file=$(strip_url $netfile)
		Fextract "${file}"
	done
}

buildenv_distcc() {
	if [ -d /usr/lib/distcc/bin ]; then
		export PATH=/usr/lib/distcc/bin:$PATH
		FCC="distcc $FCC"
		if [ "$INCHROOT" = "1" ]; then
			[ -d /var/tmp/fst/.distcc ] || mkdir /var/tmp/fst/.distcc
			export DISTCC_DIR=/var/tmp/fst/.distcc
		fi
	fi
}

buildenv_ccache() {
	if [ -d /usr/lib/ccache/bin ]; then
		if [ "$CHROOT" = "1" ]; then
			CCACHE_REALDIR=/var/cache/ccache
		else
			CCACHE_REALDIR=$CCACHE_BASEDIR
		fi
		if [ -w $CCACHE_REALDIR ]; then
			export PATH=/usr/lib/ccache/bin:$PATH
			FCC="ccache $FCC"
			install -d -m 2775 $CCACHE_REALDIR/$pkgname
			export CCACHE_DIR=$CCACHE_REALDIR/$pkgname
			export CCACHE_NOLINK=1
			export CCACHE_UMASK=002
		else
			if [ "$INCHROOT" != "1" ]; then
				error "You installed ccache but you are not in the ccache group."
				plain "Either add yourserlf to the ccache group or"
				plain "use the -B option to disable ccache support."
				exit 1
			else
				warning "The fst user is not in the ccache group, ccache will be disabled."
			fi
		fi
	fi
}

cache_clean() {
	if [ $CLEANCACHE -ge 1 ]; then
		if [ $CLEANCACHE -ge 2 ]; then
 			makepkg_ccache --clean-all
		fi
		if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
			if [ $CLEANCACHE -ge 2 ]; then
				msg "Cleaning up source files from the cache."
				rm -rf /var/cache/pacman-g2/src/*
			fi
			chroot_clean
			for i in `grep $CHROOTDIR /proc/mounts|sed 's/^[^ ]* \([^ ]*\) .*/\1/'`
			do
				umount $i
			done
			if [ "$CLEANUP" = "1" ]; then
				if [ -z "`grep $CHROOTDIR /proc/mounts`" ]; then
					msg "Removing the chroot."
					rm -rf $CHROOTDIR
				else
					error "Failed to umount some bind mounts, can't remove the chroot."
				fi
			fi
			exit 0
		else
			error "You must be root to clean the cache."
			exit 1
		fi
	fi
}

buildenv_depends_validate() {
	if [ "$NODEPS" -eq 1 ]; then
		warning "Skipping dependency checks."
		return 0
	fi
	if find_executable "$PACMAN" 'Skipping dependency checks!'; then
		return 0
	fi

	local pkgname

	for pkgname in "${_P_package_names[@]}"
	do
		# _P_package_depends is not quoted on purpose
		makedepends+=(${_P_package_depends["$pkgname"]})
	done

	msg "Checking Buildtime Dependencies..."
	makedeplist="$(checkdeps "${makedepends[@]}")"
	handledeps $makedeplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	# check deps again to make sure they were resolved
	deplist="$(checkdeps "${makedepends[@]}")"
	if [ ! -z "$deplist" ]; then
		error "Failed to install missing buildtime dependencies."
		exit 1
	fi
	msg "Checking Runtime Dependencies..."
	deplist="$(checkdeps "${depends[@]}")"
	handledeps $deplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	# check deps again to make sure they were resolved
	deplist="$(checkdeps "${depends[@]}")"
	if [ ! -z "$deplist" ]; then
		error "Failed to install missing dependencies."
		exit 1
	fi
}

buildenv_build() {
	local stime totaltime pkgsbu

	msg "Starting build()..."

	# some applications (eg, blackbox) will not build with some languages
	unset LC_ALL LANG

	if [ "`check_option NOASNEEDED`" ]; then
		msg "Using --no-as-needed in LDFLAGS"
		LDFLAGS+=" -Wl,--no-as-needed"
	else
		if [ "`check_option ASNEEDED`" ]; then
			msg "Using --as-needed in LDFLAGS"
			LDFLAGS+=" -Wl,--as-needed"
		fi
	fi
	export LDFLAGS

	stime=`date +%s`
	build
	if [ $? -gt 0 ]; then
		error "Build Failed.  Aborting..."
		exit 2
	fi

	if [ -n "`find . -name "*|*"`" ]; then
		error "Filenames in a package must not contain pipes!"
		exit 2
	fi

	# count sbu
	if [ "$SBU" == "1" ]; then
		# $SBU not yet set
		totaltime="$(( $(date +%s) - $stime ))"
		if [ -z "$HRBT" ]; then 
			msg "Elapsed Time: $totaltime seconds"
		else
			msg "Elapsed Time:$(seconds_to_human_duration "$totaltime")"
		fi
	elif [ ! -z "$SBU" ]; then
		if find_executable bc 'Cannot count SBU!'; then
			pkgsbu=`$ECHO -e "scale=2\n$(($(date +%s)-$stime))/$SBU"|bc /dev/stdin|sed 's/^\./0./'`
			msg "Elapsed Time: $pkgsbu SBU"
		fi
	fi
}

pkg_foreach() {
	local hook package_name 

	for package_name in "${_P_package_names[@]}"; do
		[ ! -d "${startdir}/pkg.${package_name}" ] && continue
		for hook in "$@"; do
			cd "${startdir}/pkg.${package_name}"
			"${hook}" "${package_name}"
		done
	done
}

pkg_mkdirs()
{
	local package_name 

	for package_name in "${_P_package_names[@]}"
	do
		mkdir -p "$startdir/pkg.$package_name"
	done

	# Compatibility
	ln -s "pkg.${_P_package_names[0]}" "$startdir/pkg"
}

pkg_rmdirs()
{
	if [ "$(ls $startdir/{pkg,pkg.*} 2> /dev/null | wc -l)" -gt 0 ]; then
		msg "Removing existing pkg and pkg.* directories..."
		rm -rf $startdir/{pkg,pkg.*}
	fi
}

pkg_print_pkginfo()
{
	local buildtype it size

	if [ "$INCHROOT" != "1" ]; then
		buildtype="custom"
	else
		buildtype="chroot"
	fi
	size=`du -cb "$startdir/pkg.$1" | tail -n 1 | awk '{print $1}'`

	$ECHO "# Generated by makepkg"
	$ECHO "# $(date)"
	$ECHO "pkgname = $1"
	$ECHO "pkgver = $pkgver-$pkgrel"
	while IFS= read -r it; do
		if [ -n "${it}" ]; then
			$ECHO "pkgdesc = ${it}"
		fi
	done <<< "${_P_package_descriptions["$1"]}"
	$ECHO "url = $url"
	$ECHO "builddate = $_P_build_date"
	$ECHO "buildtype = $buildtype"
	$ECHO "packager = $PACKAGER"
	$ECHO "size = $size"
	if [ "$CARCH" != "" ]; then
		$ECHO "arch = $CARCH"
	fi
	for it in ${_P_package_licenses["$1"]}; do
		$ECHO "license = $it"
	done
	for it in ${_P_package_replaces["$1"]}; do
		$ECHO "replaces = $it"
	done
	for it in ${_P_package_groups["$1"]}; do
		$ECHO "group = $it"
	done
	for it in ${_P_package_depends["$1"]}; do
		$ECHO "depend = $it"
	done
	for it in ${_P_package_rodepends["$1"]}; do
		$ECHO "depend = $it"
	done
	for it in ${_P_package_removes["$1"]}; do
		$ECHO "remove = $it"
	done
	for it in ${_P_package_conflicts["$1"]}; do
		$ECHO "conflict = $it"
	done
	for it in ${_P_package_provides["$1"]}; do
		$ECHO "provides = $it"
	done
	for it in ${_P_package_backups["$1"]}; do
		$ECHO "backup = $it"
	done
}

pkg_create_pkginfo() {
	msg2 "$1: .PKGINFO file..." >&2
	pkg_print_pkginfo "$1" > .PKGINFO
}

pkg_create_install() {
	local install

	# check for an install script
	install="${_P_package_installs["$1"]}"
	if [ "$install" = "" ]; then
		[ -e "$startdir/$1.install" ] && install="$1.install"
	fi
	if [ "$install" != "" ]; then
		msg2 "$1: .INSTALL file..." >&2
		if [ "`$ECHO $install |sed 's/^\(.\).*/\1/'`" = "/" ]; then
			cp "$install" '.INSTALL'
		else
			cp "$startdir/$install" '.INSTALL'
		fi
	fi
}

pkg_create_changelog() {
	if [ -f "${startdir}/Changelog" ]; then
		msg2 "$1: .CHANGELOG file... " >&2
		cp "${startdir}/Changelog" '.CHANGELOG'
	fi
}

pkg_create_filelist() {
	# build a filelist
	msg2 "$1: .FILELIST file... " >&2
	tar cvf /dev/null * | sort >.FILELIST
	# find -mindepth 1 -type d -printf "%P/\n" -o -printf "%P\n" | sort >.FILELIST
}

pkg_create_archive() {
	local i tarargs tarball

	tarball="${_P_package_archives["$1"]}"
	msg2 "Compressing $tarball" >&2

	if [ -n "$PKG_COMP" ]; then
		tarargs+=("--use-compress-program=$PKG_COMP")
	fi
	tarargs+=("-cf")
	if [ "$INCHROOT" != "1" ]; then
		tarargs+=("$PKGDEST/$tarball")
	else
		tarargs+=("../$tarball")
	fi
	tarargs+=('.PKGINFO' '.FILELIST')
	for i in '.INSTALL' '.CHANGELOG'; do
		if [ -f "$i" ]; then
			tarargs+=("$i")
		fi
	done
	tar "${tarargs[@]}" *
}

_pkg_remove_documentation_hook()
{
	rm -rf \
		usr/doc \
		usr/share/doc/"$1-$pkgver"
}

_pkg_removeemptydirs_hook()
{
	# FIXME: Make it more general (detect all dirs and try to remove them)
	# 	 and add an option (NOREMOVEEMPTYDIR) to skip this hook
	msg "$1: Removing empty dirs..."
	rmdir -p --ignore-fail-on-non-empty \
		usr/doc/ \
		usr/info/ \
		usr/man/ \
		usr/share/doc/$pkgname-$pkgver/ \
		usr/share/man/ \
		2>/dev/null
}

_pkg_strip_hook()
{
	msg "$1: Stripping debugging symbols from libraries..."
	find ./{,usr,usr/local,opt/*}/lib -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip --strip-debug '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
	msg "$1: Stripping symbols from binaries..."
	find ./{,usr,usr/local,opt/*}/{bin,sbin} -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
}

_pkg_check_links()
{
	local d="$(pwd)" l

	msg "$1: Checking symbolic links..."
	for l in `find $d -type l 2> /dev/null`; do
		if [ ! -e "$l" -a ! -e "$d/`ls -l $l | awk '{print $NF}'`" ]; then
			msg2 "$1: Maybe broken link ${l#$d} found."
		elif ls -l "$l" | awk '{print $NF}' | grep -q "$startdir"; then
			msg2 "$1: Broken link ${l#$d} found."
		fi
	done
}

create_pkg()
{
	msg "Generating files for $1:"
	cd "$startdir/pkg.$1"
	pkg_create_pkginfo "$1"
	pkg_create_install "$1"
	pkg_create_changelog "$1"
	pkg_create_filelist "$1"
	pkg_create_archive "$1"

	if [ "$SEARCHDEPS" == "1" ]; then
		if find_executable chkdep 'Cannot search depends!'; then
			msg "Searching for depends..."
			warning "Do not use this information without thinking!"
			if [ -n "$_F_makepkg_chkdep" ]; then
				chkdep -m $_F_makepkg_chkdep -d ./ -n $1 -i
			else
				chkdep -d ./ -n $1 -i
			fi
		else
			plain "Install the pacman-tools package, which contains chkdep."
			plain ""
			sleep 1
		fi
	fi
}

in_array()
{
	local i
	needle=$1
	shift 1
	# array() undefined
	[ -z "$1" ] && return 1
	for i in $*
	do
		[ "$i" == "$needle" ] && return 0
	done
	return 1
}

install_pkg()
{
	if [ "$INSTALL" -ne 1 ]; then
		return 0
	fi

	local subpkg targs

	for subpkg in "${_P_package_names[@]}"
	do
		targs+=("$PKGDEST/${_P_package_archives["${subpkg}"]}")
	done

	msg "Installing package(s) ..."
	$SUDO $PACMAN $PACMAN_OPTS -U "${targs[@]}"
	exit $?
}

repoman_loadconfig() {
	# repoman.conf for $fst_root
	[ -f /etc/repoman.conf ] && source /etc/repoman.conf

	local _serverlist serverlist

	if [ "$fst_root" = "" ]; then
		error "The fst_root environment variable is not defined, check your /etc/repoman.conf!"
		exit 1
	fi

	if [ -z "$TREE" -a ${#repos[@]} -gt 0 ]; then
		TREE="${repos[0]}"
	fi

	# see if we need to append bases to $TREE
	if ! echo "$TREE" |grep -q ,; then
		# only parse _bases if they were no provided on the commandline
		bases=$(eval "echo \$${TREE}_bases")
		[ -n "$bases" ] && TREE="$TREE,$bases"
	fi

	if [-z "$CACHEURL" ]; then
		eval "serverlist=${TREE}_servers"
		if [ "$F_makepkg_scm" = "git" -a ! "`check_option NOVERSRC`" ]; then
			_serverlist=`GIT_DIR=$fst_root/${TREE}/.git git config --get remote.origin.url 2>/dev/null`
			if [ -n "$_serverlist" -a "${_serverlist:0:6}" != "git://" ]; then
				serverlist=$_serverlist
			fi
		else
			if [ -f "$fst_root/${TREE}/_darcs/prefs/defaultrepo" ]; then
				serverlist="`cat $fst_root/${TREE}/_darcs/prefs/defaultrepo`"
			fi
		fi
		CACHEURL="${serverlist}/source/$groups/$pkgname"
	fi
}

makepkg_loadconfig() {
	# makepkg configuration
	[ -f /etc/makepkg.conf ] && source /etc/makepkg.conf

	# FIXME: Make BUILDSCRIPT a makepkg.conf variable
	BUILDSCRIPT="FrugalBuild"

	if [ -z "$PACKAGER" ]; then
		error "Please make sure that you edit /etc/makepkg.conf and set the PACKAGER= variable"
		exit 1
	fi

	if [ -z "$PKG_EXT" ]; then
		error "The PKG_EXT environment variable is not defined, check your /etc/makepkg.conf!"
#		error "Please make sure that you edit /etc/makepkg.conf and set the PKG_EXT= variable"
		exit 1
	fi

	if [ -z "$PKG_COMP" ]; then
		error "The PKG_COMP environment variable is not defined, check your /etc/makepkg.conf!"
		exit 1
	fi

	# check for a download utility
	if [ -z "$FTPAGENT" ]; then
		error "FTPAGENT is not configured. Check the /etc/makepkg.conf file."
		msg "Aborting..."
		exit 1
	elif ! find_executable "$($ECHO $FTPAGENT | awk {'print $1'})"; then
		msg "Aborting..."
		exit 1
	fi

	declare -gr \
		BUILDSCRIPT_DEFAULT="$BUILDSCRIPT" \
		PKG_COMP_DEFAULT="$PKG_COMP"

	if [ -z "$CCACHE_BASEDIR" ]; then
		export CCACHE_BASEDIR=/var/cache/ccache
	fi

	if [ "$USE_AUTO_MAKEFLAGS" != "n" ]; then
		export MAKEFLAGS="-j`grep -c ^processor /proc/cpuinfo`"
	fi
}

makepkg_usage() {
	$ECHO "makepkg"
	$ECHO
	$ECHO "Usage: $0 [command] [options] [variable assignations]"
	$ECHO "Command can be any of the following: build(default), ccache."
	$ECHO
	$ECHO "Options for build command:"
	$ECHO "  -a, --searchdeps Search for package dependencies automatically"
	$ECHO "  -A <url>         rsync cache url to use before downloading anything"
	$ECHO "  -b, --builddeps  Build missing dependencies from source"
	$ECHO "  -B, --noccache   Do not use ccache during build"
	$ECHO "  -c, --clean      Clean up work files after build"
	$ECHO "  -C, --cleancache Clean up source files from the cache"
	$ECHO "  -d, --nodeps     Skip all dependency checks"
	$ECHO "  -e, --noextract  Do not extract source files (use existing src/ dir)"
	$ECHO "  -f, --force      Overwrite existing package"
	$ECHO "  -g, --gensha1    Generate SHA1sums for source files"
	$ECHO "  -G, --wrtsha1    Generate SHA1sums for source files and add it to the build script"
	$ECHO "  -h, --help       This help"
	$ECHO "  -i, --install    Install package after successful build"
	$ECHO "  -j <jobs>        Set MAKEFLAGS to \"-j<jobs>\" before building"
	$ECHO "  -l <pkgname>     Download buildscripts before building"
	$ECHO "  -m, --nocolor    Disable colorized output messages"
	$ECHO "  -n, --nostrip    Do not strip binaries/libraries"
	$ECHO "  -o, --nobuild    Download and extract files only"
	$ECHO "  -p <buildscript> Use an alternate build script (instead of $BUILDSCRIPT_DEFAULT)"
	$ECHO "  -r, --rmdeps     Remove installed dependencies after a successful build"
	$ECHO "  -R, --chroot     Build the package in a chroot environment (default)"
	$ECHO "  -H, --host       Build the package on the host system"
	$ECHO "  -s, --syncdeps   Install missing dependencies with pacman-g2"
	$ECHO "  -S, --sudosync   Install missing dependencies with pacman-g2 and sudo"
	$ECHO "  -u, --noup2date  Do not check for newer version"
	$ECHO "  -t <tree>        Use the given tree's chroot to build in"
	$ECHO "  -w <destdir>     Write package to <destdir> instead of the working dir"
	$ECHO "  -z <compression> Use compression program for a package (instead of $PKG_COMP_DEFAULT)"
	$ECHO
	$ECHO "These options can be passed to pacman-g2:"
	$ECHO
	$ECHO "  --noconfirm      Do not ask for confirmation when resolving dependencies"
	$ECHO "  --noprogressbar  Do not show a progress bar when downloading files"
	$ECHO
	$ECHO "If -p is not specified, makepkg will look for $BUILDSCRIPT_DEFAULT"
	$ECHO "Variable assignations are user defined shell assignations (eg. USE_FOO=BAR) used to interact with makepkg and the FrugalBuilds."
	$ECHO
	$ECHO "Compatibility options (these may be removed in any future release):"
	$ECHO "  -D <pkgname>     Clean up the compiler cache for a package (See command: ccache --clean <pkgname>)"
	$ECHO "  --gzip           Use gzip compression for a package (See option: build -z <compression> )"
}

makepkg_parseargs() {
	local consumed ccache_args

	while [ $# -gt 0 ]; do
		consumed=1
		case "$1" in
# makepkg
		-a|--searchdeps)	SEARCHDEPS=1;;
		-A)			CACHEURL="$2"; consumed=2 ;;
		-b|--builddeps)		DEP_SRC=1 ;;
		-B|--noccache)		NOCCACHE=1 ;;
		-c|--clean)		CLEANUP=1 ;;
		-C|--cleancache)	CLEANCACHE=$(($CLEANCACHE+1)) ;;
		-d|--nodeps)		NODEPS=1 ;;
		-D)			ccache_args+=("--clean" "$2"); consumed=2 ;;
		-e|--noextract)		NOEXTRACT=1 ;;
		-f|--force)		FORCE=1 ;;
		-g|--gensha1)		GENSHA1=1 ;;
		-G|--wrtsha1)		WRITESHA1=1 ;;
		-h|--help)		makepkg_usage; exit 0 ;;
		-i|--install)		INSTALL=1 ;;
		-j)			export MAKEFLAGS="-j$2"; consumed=2 ;;
		-l)			DOWNLOAD="$2"; consumed=2 ;;
		-m|--nocolor)		USE_COLOR="n" ;;
		-n|--nostrip)		NOSTRIP=1 ;;
		-o|--nobuild)		NOBUILD=1 ;;
		-p)			BUILDSCRIPT="$2" ;;
		-r|--rmdeps)		RMDEPS=1 ;;
		-R|--chroot)		CHROOT=1 ;;
		-H|--host)		CHROOT=0 ;;
		-s|--syncdeps)		DEP_BIN=1 ;;
		-S|--sudosync)		DEP_SUDO=1 ;;
		-t)			TREE="$2" ;;
		-u|--noup2date)		NOUP2DATE=1 ;;
		-w)			PKGDEST="$2"; consumed=2 ;;
		-z)			PKG_COMP="$2"; consumed=2 ;;
# compatibility
		--gzip)			PKG_COMP="gzip" ;;
# internal
		--inchroot)		INCHROOT=1 ;;
		-F|--infakeroot)	INFAKEROOT=1 ;;
# pacman-g2
		--noconfirm)		PACMAN_OPTS="$PACMAN_OPTS --noconfirm" ;;
		--noprogressbar)	PACMAN_OPTS="$PACMAN_OPTS --noprogressbar" ;;
# special options
#		--)			shift; break;;
#		-*=*)			# IMPLEMENT ME: Assigned option support
		--*|-?)			makepkg_usage; exit 1 ;;
		-*)			# Combined short options
					split="$1"
					shift
					set -- \
						"$(echo "$split}" | cut -c -2)" \
						"-$(echo "${split}" | cut -c 3-)" \
						"$@"
					continue ;;
		*=*)			eval $(IFS= ; printf 'export %q=%q' "${1%%=*}" "${1#*=}") ;;
		*)			error "Optional parameter \"$1\" has unsupported format"
					exit 1 ;;
		esac
		if ! shift "$consumed"; then
			consumed=$(($consumed - 1))
			error "Option $1 expects $consumed argument(s)"
			exit 1
		fi
	done

	INCHROOT="${INCHROOT:-0}"
	if [ "$INCHROOT" -eq 1 ]; then
		CHROOT=1
	fi

	INFAKEROOT="${INFAKEROOT:-0}"
	if [ "$INFAKEROOT" -eq 1 ]; then
		NODEPS=1
		RMDEPS=0
	fi

	if [ "$INCHROOT" -eq 1 -o "$INFAKEROOT" -eq 1 ]; then
		DOWNLOAD=
		GENSHA1=0
		WRITESHA1=0
	else
		if [ ${#ccache_args[@]} -gt 0 ]; then
			makepkg_ccache "${ccache_args[@]}"
			exit $?
		fi
	fi

	WRITESHA1="${WRITESHA1:-0}"
	if [ "$WRITESHA1" -eq 1 ]; then
		# Show the sha1sums in case substitution fails
		GENSHA1="${GENSHA1:-1}"
	fi

	GENSHA1="${GENSHA1:-0}"
	if [ "$GENSHA1" -eq 1 ]; then
		NOBUILD="${NOBUILD:-1}"
		NOVALIDATE="${NOVALIDATE:-1}"
	fi

	NOBUILD="${NOBUILD:-0}"
	if [ "$NOBUILD" -eq 1 ]; then
		CHROOT="${CHROOT:-0}"
		NODEPS="${NODEPS:-1}"
	fi

	CACHEURL="${CACHEURL:-}"
	CHROOT="${CHROOT:-1}"
	CLEANUP="${CLEANUP:-0}"
	CLEANCACHE="${CLEANCACHE:-0}"
	DEP_BIN="${DEP_BIN:-0}"
	DEP_SRC="${DEP_SRC:-0}"
	DEP_SUDO="${DEP_SUDO:-0}"
	DOWNLOAD="${DOWNLOAD:-}"
	FORCE="${FORCE:-0}"
	INSTALL="${INSTALL:-0}"
	NOCCACHE="${NOCCACHE:-0}"
	NODEPS="${NODEPS:-0}"
	NODOCS="${NODOCS:-0}"
	NOEXTRACT="${NOEXTRACT:-0}"
	NOSTRIP="${NOSTRIP:-0}"
	NOUP2DATE="${NOUP2DATE:-0}"
	NOVALIDATE="${NOVALIDATE:-0}"
	PACMAN="${PACMAN:-pacman-g2.static}"
	PACMAN_OPTS="${PACMAN_OPTS:-}"
	PKGDEST="${PKGDEST:-"$startdir"}"
	RMDEPS="${RMDEPS:-0}"
	TREE="${TREE:-}"
	USE_COLOR="${USE_COLOR:-n}"

	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		if [ "$(/usr/bin/tput colors)" -lt 3 ]; then
			USE_COLOR="n"
			warning "Disabling color as the terminal does not support it."
		fi 
	fi

	if ! find_executable "$PKG_COMP"; then
		exit 1
	fi

	if [ "$(id -u)" -ne 0 -a "$DEP_SUDO" -eq 1 ]; then
		if ! find_executable sudo; then
			SUDO='sudo'
		else
			exit 1
		fi
	else
		# if we do not have enought privileges some operations will fail
		# so lets handle them early
		if [ "$NODEPS" -eq 0 ]; then
			warning "Cannot install depends as a normal user without sudo!"
			plain "Run makepkg as root or with -S to install packages automatically."
			exit 1
		fi

		if [ "$RMDEPS" -eq 1 ]; then
			warning "Cannot remove depends as a normal user without sudo!"
			plain "Run makepkg as root or with -S to install packages automatically."
			exit 1
		fi

		if [ "$INSTALL" -eq 1 ]; then
			warning "Cannot auto-install packages as a normal user without sudo!"
			plain "Run makepkg as root or with -S to install packages automatically."
			exit 1
		fi
	fi

	# convert a (possibly) relative path to absolute
	cd "$PKGDEST" 2>/dev/null
	if [ $? -ne 0 ]; then
		error "Package destination directory does not exist or permission denied."
		exit 1
	fi
	PKGDEST="$(pwd)"
	cd "$OLDPWD"
}

makepkg_prepare_sources() {
	# Generate the Changelog if necessary.
	if [ "$GENSHA1" = "0" -a "$NOBUILD" = "0" ]; then
		buildscript_create_changelog
	fi

	buildscript_up2date
	sources_download

	if [ "$NOVALIDATE" -eq 1 ]; then
		warning "Skipping source integrity checks -- using existing src/ tree"
	else
		sources_sha1sum_validate
		sources_gpg_validate
	fi

	sources_sha1sum_generate
	sources_extract

	if [ "`id -u`" = "0" ]; then
		# chown all source files to root.root
		chown -R root.root $startdir/src
	fi
	msg "Sources are ready."
}

makepkg_build() {
	if [ "$NOBUILD" -eq 1 ]; then
		return 0
	fi

	declare -gr _P_build_date=`LC_ALL= ; LANG= ; date -u "+%a %b %e %H:%M:%S %Y"`
	msg "Making package: $pkgname $pkgver-$pkgrel (${_P_build_date})"

	# use distcc if requested
	if [ "$DISTCC" = "y" ]; then
		buildenv_distcc
	fi

	# use ccache if it's available
	if [ "$NOCCACHE" = "0" -a ! "`check_option NOCCACHE`" ]; then
		buildenv_ccache
	fi

	pkg_rmdirs
	pkg_mkdirs

	# In a subshell so makepkg env is not altered
	( buildenv_build )

	makepkg_document

	# NOTE: _P_subpkgsfixes hook registration order is important.
	#if ! check_option NOREMOVEEMPTYDIR; then
		_P_subpkgsfixes+=(_pkg_removeemptydirs_hook)
	#fi

	if [ ! "`check_option NOSTRIP`" -a "$NOSTRIP" = "0" ]; then
		_P_subpkgsfixes+=(_pkg_strip_hook)
	fi

	_P_subpkgsfixes+=(_pkg_check_links)
	_P_subpkgsfixes+=(create_pkg)
	pkg_foreach "${_P_subpkgsfixes[@]}"

	msg "Finished making: $pkgname  (`date`)"
}

# FIXME: This code rely on "$startdir/pkg/" path
makepkg_document() {

	if [ "`check_option NODOCS`" -o "$NODOCS" = "1" ]; then
		_P_subpkgsfixes+=(_pkg_remove_documentation_hook)
		return 0
	fi

	msg "Preparing package documentation..."

	cd $startdir
	mkdir -p pkg/usr/share/doc/$pkgname-$pkgver
	find src -maxdepth 2 -size +0b \( \
		    -name ANNOUNCE \
		-or -name AUTHORS \
	  	-or -name '*BUGS*' \
		-or -name CHANGES \
		-or -name CONFIGURATION \
		-or -name '*COPYING*' \
		-or -name '*COPYRIGHT*' \
		-or -name CREDITS \
		-or -name ChangeLog \
		-or -name Changelog \
		-or -name CHANGELOG \
		-or -name CONTRIBUTORS \
		-or -name '*FAQ*' \
		-or -name FEATURES \
		-or -name FILES \
		-or -name HACKING \
		-or -name History \
		-or -name HISTORY \
		-or -name 'INSTALL*' \
		-or -name LICENSE \
		-or -name LSM \
		-or -name MANIFEST \
		-or -name NEWS \
		-or -name '*README*' \
		-or -name '*Readme*' \
		-or -name SITES \
		-or -name '*RELEASE*' \
		-or -name RELNOTES \
		-or -name THANKS \
		-or -name TIPS \
		-or -name TODO \
		-or -name VERSION \
		-or -name 'CONFIGURATION*' \
		-or -name GPLLicense \
		\) -exec install -pm 644 '{}' pkg/usr/share/doc/$pkgname-$pkgver/ \;
}

makepkg_build_cmd() {
	declare -r ARGLIST=$@
	makepkg_parseargs "$@"
	repoman_loadconfig

	if [ "$INCHROOT" = "1" ]; then
		$ECHO $$ >lock
	fi

	cache_clean

	buildscript_download

	buildscript_load

	if [ -f "$PKGDEST/${_P_package_archives["${pkgname}"]}" -a "$FORCE" = "0" -a "$GENSHA1" = "0" ]; then
		if [ "$INSTALL" = "1" ]; then
			warning "a package has already been built, installing existing package."
			install_pkg
		else
			error "a package has already been built.  (use -f to overwrite)"
			exit 1
		fi
	fi

	# Build chroot environment if necessary.
	chroot_enter
	fakeroot_enter

	unset deplist makedeplist
	buildenv_depends_validate

	cd $startdir

	buildscript_estimation

	makepkg_prepare_sources
	if [ "$NOBUILD" = "1" ]; then
		exit 0
	else
		makepkg_build
	fi

	cd $startdir
	if [ "$CLEANUP" = "1" ]; then
		if [ "$INCHROOT" == "1" ]; then
			msg "Chroot size before cleaning: $(chroot_size)"
		fi
		msg "Cleaning up..."
		pkg_rmdirs
		rm -rf src Changelog
	fi

	if [ "$RMDEPS" = "1" -a \( ! -z "$deplist" -o ! -z "$makedeplist" \) ]; then
		msg "Removing installed dependencies..."
		$SUDO $PACMAN $PACMAN_OPTS -R $makedeplist $deplist
	fi

	install_pkg
}

makepkg_ccache_usage() {
	$ECHO "makepkg"
	$ECHO
	$ECHO "Usage: $0 ccache [options]"
	$ECHO
	$ECHO "Options for ccache command:"
	$ECHO "      --clean <pkgname>  Clean up the compiler cache for a package"
	$ECHO "      --clean-all        Clean up the compiler cache for all packages"
	$ECHO "  -h, --help             This help"
}

makepkg_ccache() {
	local clean_list clean_all=0 i consumed

	while [ $# -gt 0 ]; do
		consumed=1
		case "$1" in
		--clean)		ccache_clean_list+=("$2"); consumed=2 ;;
		--clean-all)		clean_all=1 ;;
		-h|--help)		makepkg_ccache_usage; return 0 ;;
# special options
#		--)			shift; break;;
		--*|-?)			makepkg_ccache_usage; return 1 ;;
		-*)			# Combined short options
					split="$1"
					shift
					set -- \
						"$(echo "$split}" | cut -c -2)" \
						"-$(echo "${split}" | cut -c 3-)" \
						"$@"
					continue ;;
		*)			error "Optional parameter \"$1\" has unsupported format"
					return 1 ;;
		esac
		if ! shift "$consumed"; then
			consumed=$(($consumed - 1))
			error "Option $1 expects $consumed argument(s)"
			return 1
		fi
	done

	if [ $clean_all -eq 1 ]; then
		msg "Cleaning up the compiler cache."
		CCACHE_DIR="$CCACHE_BASEDIR" ccache -C
	else
		for i in "$@"; do
			if [ -n "$cache" -a -d "$CCACHE_BASEDIR/$i" ]; then
				msg "$cache: Cleaning up the compiler cache."
				CCACHE_DIR="$CCACHE_BASEDIR/$i" ccache -C
			else
				error "$i: No compiler cache available"
			fi
		done
	fi
	return 0
}

makepkg_clean() {
	return 1
}

makepkg_install() {
	return 1
}

makepkg_main() {
	makepkg_loadconfig
	case "$1" in
	build)		shift; makepkg_build_cmd "$@" ;;
	ccache)		shift; makepkg_ccache "$@" ;;
	clean)		shift; makepkg_clean "$@" ;;
	install)	shift; makepkg_install "$@" ;;
	*)		makepkg_build_cmd ;;
	esac
}

#
# Package fixes that may go to a library (user helpers)
#

_pkg_perl_cleanup_hook() {
	msg "$1: Removing unwanted perl files..."

	for f in `find usr/lib/perl? -type f 2> /dev/null`; do
		case "$f" in
			*/.packlist|*/perllocal.pod)
				rm -f "$f"
				rmdir -p --ignore-fail-on-non-empty `dirname $f` 2> /dev/null
			;;
		esac
	done
}
_P_subpkgsfixes+=(_pkg_perl_cleanup_hook)

_pkg_info_cleanup_hook() {
	msg "$1: Removing unwanted info files..."

	rm -f {usr{,/local,/share},opt/*}/info/dir 2> /dev/null
}
_P_subpkgsfixes+=(_pkg_info_cleanup_hook)

_pkg_mkfontdir_cleanup_hook() {
	msg "$1: Removing unwanted mkfontdir files..."

	for f in `find -type f -name encodings.dir -o -type f -name fonts.dir -o -type f -name fonts.scale`; do
		msg2 "`$ECHO $f | sed 's|^./||'`"
		rm -f "$f"
	done
}
_P_subpkgsfixes+=(_pkg_mkfontdir_cleanup_hook)

_pkg_move_doc_hook()
{
	if [ -d usr/doc ]; then
		mkdir -p "usr/share/doc/$pkgname-$pkgver"
		mv usr/doc/* "usr/share/doc/$pkgname-$pkgver"
		rmdir usr/doc
	fi
}
_P_subpkgsfixes+=(_pkg_move_doc_hook)

_pkg_move_info_hook()
{
	# move /usr/info files to /usr/share/info
	if [ -d usr/info ]; then
		mkdir -p usr/share/info
		mv usr/info/* usr/share/info/
		rmdir usr/info
	fi
}
_P_subpkgsfixes+=(_pkg_move_info_hook)

_pkg_move_man_hook()
{
	# move /usr/man files to /usr/share/man
	if [ -d usr/man ]; then
		mkdir -p usr/share/man
		mv usr/man/* usr/share/man/
		rmdir usr/man
	fi
}
_P_subpkgsfixes+=(_pkg_move_man_hook)

_pkg_compress_manuals_hook()
{
	local ext fn i ln

	msg "$1: Compressing info and manual pages..."
	find {usr{,/local,/share},opt/*}/{info,man} -type f 2>/dev/null | while read i; do
		ext="${i##*.}"
		fn="${i##*/}"
		if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
			# update symlinks to this manpage
			find {usr{,/local,/share},opt/*}/man -lname "$fn" 2> /dev/null | while read ln; do
				rm -f "$ln"
				ln -sf "${fn}.gz" "${ln}.gz"
			done
			# compress the original
			gzip -9 "$i"
		fi
	done
}
_P_subpkgsfixes+=(_pkg_compress_manuals_hook)

_pkg_check_hicolor()
{
	if [ -d "usr/share/icons/hicolor" ]; then
		if [ -z "$_F_gnome_iconcache" ]; then
			warning "$1: Package contains hicolor icons but _F_gnome_iconcache is not set"
		fi
	fi
}
_P_subpkgsfixes+=(_pkg_check_hicolor)

#
# Main Code Start here
#

makepkg_main "$@"
