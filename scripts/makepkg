#!/bin/bash
# 
#   makepkg
#  
#   Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
#   Copyright (c) 2005-2006 by Miklos Vajna <vmiklos@frugalware.org>
#  
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#  
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
#   USA.
#

myver='2.9.8'
startdir=`pwd`
PKGDEST=$startdir
USE_COLOR="n"

# Options
BUILDSCRIPT="./FrugalBuild"
CLEANUP=0
CLEANCACHE=0
CLEANCCACHE=""
DEP_BIN=0
DEP_SRC=0
DEP_SUDO=0
FORCE=0
GENSHA1=0
GENMD5=0
INSTALL=0
DOWNLOAD=""
NOLASTMOD=0
NOBUILD=0
NOCCACHE=0
NODEPS=0
NOEXTRACT=0
NOSTRIP=0
RMDEPS=0
CHROOT=0
LOGGING=0
NOUP2DATE=0
GZIP=0
NOSTRIP=0
NODOCS=0
TREE="current"

PACMAN_OPTS=

# Frugalware extensions to makepkg
[ -e /usr/lib/frugalware/fwmakepkg ] && . /usr/lib/frugalware/fwmakepkg

# repoman.conf for $fst_root
[ -f /etc/repoman.conf ] && source /etc/repoman.conf

# makepkg configuration
[ -f /etc/makepkg.conf ] && source /etc/makepkg.conf

INFAKEROOT=
if [ "$1" = "-F" ]; then
	INFAKEROOT=1
	shift
fi

INCHROOT=
if [ "$1" = "--inchroot" ]; then
	INCHROOT=1
	shift
fi

### SUBROUTINES ###

plain() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "    \033[1;1m$1\033[1;0m" >&2
	else
		echo "    $1" >&2
	fi
}
msg() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;32m==>\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> $1" >&2
	fi
}

msg2() {
        if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
                echo -e "   \033[1;34m->\033[1;0m \033[1;1m$1\033[1;0m" >&2
        else
                echo "   -> $1" >&2
        fi
}

warning() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;33m==> WARNING:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> WARNING: $1" >&2
	fi
}
error() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;31m==> ERROR:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> ERROR: $1" >&2
	fi
}

strip_url() {
	echo "$1" | sed 's|^.*://.*/||g'
}

checkdeps() {
	local missdep=""
	local deplist=""

	[ $# -gt 0 ] || return

	missdep=`pacman $PACMAN_OPTS -T $*`
	ret=$?
	if [ "$ret" != "0" ]; then
		if [ "$ret" = "127" ]; then
			msg "Missing Dependencies:"
			msg ""
			nl=0
			for dep in $missdep; do
				echo -ne "$dep " >&2
				if [ "$nl" = "1" ]; then
					nl=0
					echo -ne "\n" >&2
					# add this dep to the list
					depname=`echo $dep | sed 's|=.*$||' | sed 's|>.*$||' | sed 's|<.*$||'`
					deplist="$deplist $depname"
					continue
				fi
				nl=1
			done
			msg ""
		else
			error "pacman returned a fatal error."
			exit 1
		fi
	fi
	echo $deplist
}

handledeps() {
	local missingdeps=0
	local deplist="$*"
	local haveperm=0
	if [ \( "`id -u`" = "0" -a "$INFAKEROOT" != "1" \) -o "$DEP_SUDO" = 1 ]; then
		haveperm=1
	fi

	if [ "$deplist" != "" -a $haveperm -eq 1 ]; then
		if [ "$DEP_BIN" = "1" ]; then
			# install missing deps from binary packages (using pacman -S)
			msg "Installing missing dependencies..."
			if [ "$INCHROOT" != "1" -o "`check_option SCRIPTLET`" ]; then
				pacman $PACMAN_OPTS -D $deplist
			else
				pacman $PACMAN_OPTS --noscriptlet -D $deplist
			fi
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
		elif [ "$DEP_SUDO" = "1" ]; then
			# install missing deps from binary packages (using pacman -S and sudo)
			msg "Installing missing dependencies..."
			if [ "$INFAKEROOT" = "1" ]; then
				# kinda hacky, but we need to make pacman think that we're NOT
				# in fakeroot so it will go ahead and install the dependencies.
				FAKEROOTKEY2=$FAKEROOTKEY
				unset FAKEROOTKEY
			fi
			if [ "$INCHROOT" != "1" -o "`check_option SCRIPTLET`" ]; then
				sudo pacman $PACMAN_OPTS -D $deplist
			else
				sudo pacman $PACMAN_OPTS --noscriptlet -D $deplist
			fi
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
			if [ "$INFAKEROOT" = "1" ]; then
				export FAKEROOTKEY=$FAKEROOTKEY2
				unset FAKEROOTKEY2
			fi
		elif [ "$DEP_SRC" = "1" ]; then
			# install missing deps by building them from source.
			# we look for each package name in $fst_root and build it.
			if [ "$fst_root" = "" ]; then
				error "The fst_root environment variable is not defined, check your /etc/repoman.conf!"
				exit 1
			fi
			# TODO: handle version comparators (eg, glibc>=2.2.5)
			msg "Building missing dependencies..."
			for dep in $deplist; do
				candidates=`find $fst_root -type d -name "$dep"`
				if [ "$candidates" = "" ]; then
					error "Could not find \"$dep\" under $fst_root"
					exit 1
				fi
				success=0
				for pkgdir in $candidates; do
					if [ -f $pkgdir/FrugalBuild ]; then
						cd $pkgdir
						if [ "$RMDEPS" = "1" ]; then
							makepkg -i -c -b -r -w $PKGDEST
						else
							makepkg -i -c -b -w $PKGDEST
						fi
						if [ $? -eq 0 ]; then
							success=1
							break
						fi
					fi
				done
				if [ "$success" = "0" ]; then
					error "Failed to build \"$dep\""
					exit 1
				fi
			done
		else
			missingdeps=1
		fi
	elif [ "$deplist" != "" -a $haveperm -eq 0 ]; then
		if [ "$DEP_SRC" = "1" -o "$DEP_BIN" = "1" ]; then
			warning "Cannot auto-install missing dependencies as a normal user without sudo!"
			plain "Run makepkg as root or with -S to resolve dependencies automatically."
		fi
		missingdeps=1
	fi
	# rerun any additional sh scripts found in /etc/profile.d/
	for i in /etc/profile.d/*.sh
	do
		if [ -x $i ]; then
			. $i &>/dev/null
		fi
	done
	# some applications (eg, blackbox) will not build with some languages
	unset LC_ALL LANG

	return $missingdeps
}

usage() {
	echo "makepkg version $myver"
	echo
	echo "Usage: $0 [options]"
	echo
	echo "Options:"
	echo "  -a, --searchdeps Search for package dependencies automatically"
	echo "  -b, --builddeps  Build missing dependencies from source"
	echo "  -B, --noccache   Do not use ccache during build"
	echo "  -c, --clean      Clean up work files after build"
	echo "  -C, --cleancache Clean up source files from the cache"
	echo "  -d, --nodeps     Skip all dependency checks"
	echo "  -D <pkgname>     Clean up the compiler cache for a package"
	echo "  -e, --noextract  Do not extract source files (use existing src/ dir)"
	echo "  -f, --force      Overwrite existing package"
	echo "  -g, --gensha1    Generate SHA1sums for source files"
	echo "  -G, --genmd5     Generate MD5sums for source files"
	echo "  -h, --help       This help"
	echo "  -i, --install    Install package after successful build"
	echo "  -j <jobs>        Set MAKEFLAGS to \"-j<jobs>\" before building"
	echo "  -k, --logging    Logging package build process"
	echo "  -l <pkgname>     Download buildscripts before building"
	echo "  -L, --nolastmod  Do not update the \"Last modified\" line"
	echo "  -m, --nocolor    Disable colorized output messages"
	echo "  -n, --nostrip    Do not strip binaries/libraries"
	echo "  -o, --nobuild    Download and extract files only"
	echo "  -p <buildscript> Use an alternate build script (instead of FrugalBuild)"
	echo "  -r, --rmdeps     Remove installed dependencies after a successful build"
	echo "  -R, --chroot     Build the package in a chroot environment"
	echo "  -s, --syncdeps   Install missing dependencies with pacman"
	echo "  -S, --sudosync   Install missing dependencies with pacman and sudo"
	echo "  -u, --noup2date  Do not check for newer version"
	echo "  -t <tree>        Use the given tree's chroot to build in"
	echo "  -w <destdir>     Write package to <destdir> instead of the working dir"
	echo "  --gzip           Use gzip compression for a package instead of bzip2"
	echo
	echo "These options can be passed to pacman:"
	echo
	echo "  --noconfirm      Do not ask for confirmation when resolving dependencies"
	echo "  --noprogressbar  Do not show a progress bar when downloading files"
	echo
	echo "If -p is not specified, makepkg will look for ./FrugalBuild"
	echo
}

chroot_umount() {
    msg "Attempting to umount chroot directories..."
    umount $CHROOTDIR/proc >/dev/null
    umount $CHROOTDIR/sys >/dev/null
    umount $CHROOTDIR/dev >/dev/null
    umount $CHROOTDIR/var/cache/pacman >/dev/null
    umount $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to umount chroot directories."
	exit 1
    fi
    msg "Successfully umounted chroot directories."
}

chroot_mount() {
    msg "Attempting to mount chroot directories..."
    mount -t proc none $CHROOTDIR/proc >/dev/null &
    mount -t sysfs none $CHROOTDIR/sys >/dev/null &
    mount -o bind /dev $CHROOTDIR/dev >/dev/null &
    mount -o bind /var/cache/pacman $CHROOTDIR/var/cache/pacman >/dev/null &
    mount -o bind /var/cache/ccache/$pkgname \
    $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null &
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to mount chroot directories."
	exit 1
    fi
    msg "Successfully mounted chroot directories."
}

chroot_clean()
{
	if [ "$CHROOT" = "1" ]; then
		echo $CHROOTDIR |grep -q $TREE$ || CHROOTDIR="$CHROOTDIR/$TREE"
		msg "Cleaning chroot."
		rm -rf $CHROOTDIR/var/tmp/fst/*
		msg "Removing unnecessary packages."
		for i in "$COREPKGS"
		do
			corelist="$corelist `pacman -r $CHROOTDIR -Sg $i --config $CHROOTDIR/etc/pacman.conf |grep -v '^\w'`"
		done
		for i in `pacman -r $CHROOTDIR -Q|sed 's/\([^ ]*\) .*/\1/'`
		do
			if ! echo $corelist |grep -q $i; then
				removelist="$removelist $i"
			fi
		done
		if [ ! -z "$removelist" ]; then
			pacman -r $CHROOTDIR -Rcn $removelist --noconfirm
			if [ "$?" != "0" ]; then
				error "Failed to remove packages."
				exit 1
			fi
		fi
	fi
}

create_pkg()
{
	msg "Generating files for $1:"
	# write the .PKGINFO file
	msg2 ".PKGINFO file... " >&2
	if [ "$1" = "$pkgname" ]; then
		cd $startdir/pkg
	else
		cd $startdir/pkg.$1
	fi
	size=`du -cb . | tail -n 1 | awk '{print $1}'`
	echo "# Generated by makepkg $myver" >.PKGINFO
	echo -n "# " >>.PKGINFO
	date >>.PKGINFO
	echo "pkgname = $1" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc" >>.PKGINFO
	for it in "${pkgdesc_localized[@]}"; do
		echo "pkgdesc = $it" >>.PKGINFO
	done
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ "$CARCH" != "" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi

	for it in ${license[@]}; do
		echo "license = $it" >>.PKGINFO
	done
	for it in ${replaces[@]}; do
		echo "replaces = $it" >>.PKGINFO
	done
	for it in ${groups[@]}; do
		echo "group = $it" >>.PKGINFO
	done
	for it in ${depends[@]}; do
		echo "depend = $it" >>.PKGINFO
	done
	for it in ${rodepends[@]}; do
		echo "depend = $it" >>.PKGINFO
	done
	for it in ${removes[@]}; do
		echo "remove = $it" >>.PKGINFO
	done
	for it in ${conflicts[@]}; do
		echo "conflict = $it" >>.PKGINFO
	done
	for it in ${provides[@]}; do
		echo "provides = $it" >>.PKGINFO
	done
	for it in ${backup[@]}; do
		echo "backup = $it" >>.PKGINFO
	done

	# check for an install script
	if [ "$install" == "" ]; then
		[ -e $startdir/$1.install ] && install=$1.install
	fi
	if [ "$install" != "" ]; then
		msg2 ".INSTALL file... " >&2
		if [ "`echo $install |sed 's/^\(.\).*/\1/'`" = "/" ]; then
			cp $install .INSTALL
		else
			cp $startdir/$install .INSTALL
		fi
	fi

	if [ -f $startdir/Changelog ]; then
		msg2 ".CHANGELOG file... " >&2
		cp $startdir/Changelog .CHANGELOG
	fi

	# build a filelist
	msg2 ".FILELIST file... " >&2
	tar cvf /dev/null * | sort >.FILELIST

	# tar it up
	msg2 "Compressing $1-$pkgver-$pkgrel-$CARCH.fpm " >&2
	unset extra
	if [ -f .INSTALL ]; then
		extra=".INSTALL"
	fi
	if [ -f .CHANGELOG ]; then
		extra="$extra .CHANGELOG"
	fi

	if [ "$GZIP" == "1" ]; then
		tarargs="czvf"
		warning "Using gzip compression - this is not optimal!"
	else
		tarargs="cjvf"
	fi

	if [ "$INCHROOT" != "1" ]; then
		tar $tarargs $PKGDEST/$1-$pkgver-$pkgrel-$CARCH.fpm .PKGINFO .FILELIST \
		$extra * | sort >../filelist
	else
		tar $tarargs ../$1-$pkgver-$pkgrel-$CARCH.fpm .PKGINFO .FILELIST \
			$extra * | sort >../filelist
	fi

	if [ "$SEARCHDEPS" == "1" ]; then
		if [ -x /usr/bin/chkdep ]; then
			msg "Searching for depends..."
			warning "Do not use this information without thinking!"
			chkdep -d ./ -n $1 -i
		else
			warning "Chkdep is not installed and is required to search depends."
			plain "Install the pacman-tools package, which contains chkdep."
			plain ""
			sleep 1
		fi
	fi
}

in_array()
{
	needle=$1
	shift 1
	# array() undefined
	[ -z "$1" ] && return 1
	for i in $*
	do
		[ "$i" == "$needle" ] && return 0
	done
	return 1
}

install_pkg()
{
	if [ "$INSTALL" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
		msg "Installing package(s) with pacman -U..."
		targs="$PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm"
		if [ ! -z "$subpkgs" ]; then
			i=0
			for subpkg in "${subpkgs[@]}"
			do
				targs="$targs $PKGDEST/${subpkg}-${pkgver}-${pkgrel}-${CARCH}.fpm"
			done
		fi
		pacman $PACMAN_OPTS -U $targs || exit $?
	elif [ "$INSTALL" = "1" -a "$DEP_SUDO" = "1" ]; then
		msg "Installing package(s) with sudo pacman -U..."
		targs="$PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm"
		if [ ! -z "$subpkgs" ]; then
			i=0
			for subpkg in "${subpkgs[@]}"
			do
				targs="$targs $PKGDEST/${subpkg}-${pkgver}-${pkgrel}-${CARCH}.fpm"
			done
		fi
		if [ "$INFAKEROOT" = "1" ]; then
			FAKEROOTKEY2=$FAKEROOTKEY
			unset FAKEROOTKEY
		fi
		sudo pacman $PACMAN_OPTS -U $targs || exit $?
		if [ "$INFAKEROOT" = "1" ]; then
			export FAKEROOTKEY=$FAKEROOTKEY2
			unset FAKEROOTKEY2
		fi
	elif [ "$INSTALL" = "1" ]; then
		warning "Cannot auto-install packages as a normal user without sudo!"
		plain "Run makepkg as root or with -S to install packages automatically."
	fi
	exit 0
}

ARGLIST=$@

while [ "$#" -ne "0" ]; do
	case $1 in
# pacman
		--noconfirm)      PACMAN_OPTS="$PACMAN_OPTS --noconfirm" ;;
		--noprogressbar)  PACMAN_OPTS="$PACMAN_OPTS --noprogressbar" ;;
# makepkg
		--searchdeps) SEARCHDEPS=1 ;;
		--clean)      CLEANUP=1 ;;
		--cleancache) CLEANCACHE=$(($CLEANCACHE+1)) ;;
		--syncdeps)   DEP_BIN=1 ;;
		--sudosync)   DEP_SUDO=1 ;;
		--builddeps)  DEP_SRC=1 ;;
		--noccache)   NOCCACHE=1 ;;
		--nodeps)     NODEPS=1 ;;
		--noextract)  NOEXTRACT=1 ;;
		--install)    INSTALL=1 ;;
		--nolastmod)  NOLASTMOD=1 ;;
		--force)      FORCE=1 ;;
		--nostrip)    NOSTRIP=1 ;;
		--nobuild)    NOBUILD=1 ;;
		--nocolor)    USE_COLOR="n" ;;
		--gensha1)    GENSHA1=1 ;;
		--genmd5)     GENMD5=1 ;;
		--rmdeps)     RMDEPS=1 ;;
		--chroot)     CHROOT=1 ;;
		--noup2date)  NOUP2DATE=1 ;;
		--logging)    LOGGING=1 ;;
		--gzip)       GZIP=1 ;;
		--help)
			usage
			exit 0
			;;
		--*)
			usage
			exit 1
			;;
		-*)
			while getopts "abBcCdD:efgGhij:kl:Lmnop:urRsSt:w:-" opt; do
				case $opt in
					a) SEARCHDEPS=1 ;;
					b) DEP_SRC=1 ;;
					B) NOCCACHE=1 ;;
					c) CLEANUP=1 ;;
					C) CLEANCACHE=$(($CLEANCACHE+1)) ;;
					d) NODEPS=1 ;;
					D) CLEANCCACHE=$OPTARG ;;
					e) NOEXTRACT=1 ;;
					f) FORCE=1 ;;
					g) GENSHA1=1 ;;
					G) GENMD5=1 ;;
					h)
						usage
						exit 0
						;;
					i) INSTALL=1 ;;
					j) export MAKEFLAGS="-j$OPTARG" ;;
					k) LOGGING=1 ;;
					l) DOWNLOAD="$OPTARG" ;;
					L) NOLASTMOD=1 ;;
					m) USE_COLOR="n" ;;
					n) NOSTRIP=1 ;;
					o) NOBUILD=1 ;;
					p) BUILDSCRIPT=$OPTARG ;;
					r) RMDEPS=1 ;;
					R) CHROOT=1 ;;
					s) DEP_BIN=1 ;;
					S) DEP_SUDO=1 ;;
					t) TREE="$OPTARG" ;;
					u) NOUP2DATE=1 ;;
					w) PKGDEST=$OPTARG ;;
					-)
						OPTIND=0
						break
						;;
					*)
						usage
						exit 1
						;;
				esac
			done
			;;
		*)
			true
			;;
	esac
	shift
done

# check for sudo
if [ "$DEP_SUDO" = "1" -a ! "`type -p sudo`" ]; then
	error "Cannot find the sudo binary! Is sudo installed?"
	exit 1
fi

# convert a (possibly) relative path to absolute
cd $PKGDEST 2>/dev/null
if [ $? -ne 0 ]; then
	error "Package destination directory does not exist or permission denied."
	exit 1
fi
PKGDEST=`pwd`
cd $OLDPWD

if [ ! -z "$CLEANCCACHE" ]; then
	export CCACHE_DIR=/var/cache/ccache/$CLEANCCACHE
	ccache -C
	exit 0
fi

if [ $CLEANCACHE -ge 1 ]; then
	if [ $CLEANCACHE -ge 2 ]; then
		msg "Cleaning up the compiler cache."
		export CCACHE_DIR=/var/cache/ccache
		ccache -C
	fi
	if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
		if [ $CLEANCACHE -ge 2 ]; then
			msg "Cleaning up source files from the cache."
			rm -rf /var/cache/pacman/src/*
		fi
		chroot_clean
		exit 0
	else
		error "You must be root to clean the cache."
		exit 1
	fi
fi

unset pkgname pkgver pkgrel pkgdesc url license groups provides md5sums force
unset replaces depends removes conflicts backup source install makedepends
unset rodepends options pkdesc_localized
umask 0022

# download buildscript if necessary
if [ ! -z "$DOWNLOAD" -a "$INFAKEROOT" != "1" ]; then
	msg "Retrieving $DOWNLOAD's buildscript..."
	
	# find the package
	if ! pacman -Si $DOWNLOAD >/dev/null 2>&1; then
		error "Package \"$DOWNLOAD\" was not found."
		exit 1
	fi
	
	# check for a download utility
	if [ -z "$FTPAGENT" ]; then
		error "FTPAGENT is not configured. Check the /etc/makepkg.conf file."
		msg "Aborting..."
		exit 1
	fi
	ftpclient=`echo $FTPAGENT | awk {'print $1'}`
	if [ ! -x $ftpclient ]; then
		error "ftpclient `basename $ftpclient` is not installed."
		msg "Aborting..."
		exit 1
	fi
	
	confs=`cat /etc/pacman.conf |grep ^Include|sed 's/.* = \(.*\)/\1/'`
	# TODO: -q option to download the src tarballs from Frugalware mirrros
	quickdl="_darcs/current/"
	
	# searching for a mirror
	repo=`pacman -Si $DOWNLOAD |grep ^Repo |sed -n 's/.* \([^ ]*\)/\1/;1 p'`
	dir=`grep ^Server /etc/pacman.d/$repo |sed -n 's/.* = \(.*\)/\1/;1 p'`
	arch=`grep ^Server /etc/pacman.d/$repo |sed -n 's/.*-\(.*\)/\1/;1 p'`
	cat=`pacman -Si $DOWNLOAD |grep ^G |sed 's/.* : \([^ ]*\) .*/\1/; s/-extra$//'`
	dlpath=`echo "$dir/../$quickdl"|sed "s|extra/frugalware-$CARCH/../$quickdl|${quickdl}extra/frugalware-$CARCH/../|"`
	
	# download the script
	mkdir $DOWNLOAD
	cd $DOWNLOAD
	# FIXME: apps other than wget maybe not support -m
	$FTPAGENT -m $dlpath/source/$cat/$DOWNLOAD/ 2>&1
	if [ ! -f $file ]; then
		error "Failed to download $file"
		msg "Aborting..."
		exit 1
	fi
	junk=`echo $dir|sed "s|^ftp://\(.*\)/frugalware-$arch|\1/$quickdl|;s|extra/$quickdl|${quickdl}extra/|"`/source/$cat/$DOWNLOAD/
	mv $junk* ./
	rm -rf `echo $junk|cut -d/ -f1`
	for i in `find * -type d`
	do
		( cd $i && [ -e .listing ] && rm .listing )
	done
fi

if [ ! -f $BUILDSCRIPT ]; then
	error "$BUILDSCRIPT does not exist."
	exit 1
fi

source $BUILDSCRIPT

# check for no-no's
if [ `echo $pkgver | grep '-'` ]; then
	error "pkgver is not allowed to contain hyphens."
	exit 1
fi
if [ `echo $pkgrel | grep '-'` ]; then
	error "pkgrel is not allowed to contain hyphens."
	exit 1
fi
if ! in_array $CARCH ${archs[@]}; then
	error "$pkgname is not available on $CARCH."
	exit 1
fi
if [ "$install" -a ! -f "$install" ]; then
	warning "install scriptlet ($install) does not exist."
fi

if [ -f $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm -a "$FORCE" = "0" -a "$GENMD5" = "0" -a "$GENSHA1" = "0" ]; then
	if [ "$INSTALL" = "1" ]; then
		warning "a package has already been built, installing existing package."
		install_pkg
	else
		error "a package has already been built.  (use -f to overwrite)"
		exit 1
	fi
fi

# Generate the Changelog if necessary.
if darcs --commands 2>&1|grep -q add && [ "$GENMD5" = "0" -a "$GENSHA1" = "0" -a "$NOBUILD" = "0" ]; then
	if [ ! -e Changelog ] || [ `stat -c %Y Changelog` -lt `stat -c %Y $BUILDSCRIPT` ]; then
		msg "Generating the Changelog..."
		darcs changes $BUILDSCRIPT |sed "s|\(.*\)source/\(.*\)/FrugalBuild\(.*\)|\1\2\3|;/Can't find changes prior to:/,\$d" >Changelog
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %u:%g FrugalBuild` \
				Changelog
		fi
	fi
fi
# Build chroot environment if necessary.
if [ "$CHROOT" = "1" -a "$INCHROOT" != "1" ]; then
	if [ "`id -u`" != 0 ]; then
		error "Building in a chroot as an unprivileged user is not possible."
		exit 1
	fi
	if [ "$CHROOTDIR" = "" ]; then
		error "The CHROOTDIR environment variable is not defined."
		exit 1
	fi
	CHROOTDIR="$CHROOTDIR/$TREE"

	mkdir -p $CHROOTDIR/{dev,etc,proc,sys,var/cache/pacman,var/tmp/fst}

	if [ -e $CHROOTDIR/var/tmp/fst/lock ]; then
		error "Somebody already building in this chroot."
		plain "If you're sure makepkg is not already running, you"
		plain "can remove $CHROOTDIR/var/tmp/fst/lock."
		exit 1
	else
		touch $CHROOTDIR/var/tmp/fst/lock
	fi

	install -d -m 2775 {,$CHROOTDIR}/var/cache/ccache/$pkgname

	chroot_mount

	if [ ! -d "$CHROOTDIR/usr" -o ! -e "$CHROOTDIR/etc/pacman.conf" ]; then
		msg "Building a '-$TREE' chroot environment"
		_F_makepkg_pacconf=`mktemp`
		if grep -q ^Include.*current$ /etc/pacman.conf; then
			if [ "$TREE" = "current" ]; then
				# host: current, chroot: current
				cat /etc/pacman.conf >$_F_makepkg_pacconf
			else
				# host: current, chroot: stable
				cat /etc/pacman.conf |sed 's|^\(Include = /etc/pacman.d/frugalware-current$\)|#\1|
					s|^\(Include = /etc/pacman.d/extra-current$\)|#\1|
					s|^#\(Include = /etc/pacman.d/frugalware$\)|\1|
					s|^#\(Include = /etc/pacman.d/extra$\)|\1|' >$_F_makepkg_pacconf
			fi
		else
			if [ "$TREE" = "current" ]; then
				# host: stable, chroot: current
				cat /etc/pacman.conf |sed 's|^#\(Include = /etc/pacman.d/frugalware-current$\)|\1|
					s|^#\(Include = /etc/pacman.d/extra-current$\)|\1|
					s|^\(Include = /etc/pacman.d/frugalware$\)|#\1|
					s|^\(Include = /etc/pacman.d/extra$\)|#\1|' >$_F_makepkg_pacconf
			else
				# host: stable, chroot: stable
				cat /etc/pacman.conf >$_F_makepkg_pacconf
			fi
		fi
		mkdir -p "$CHROOTDIR/tmp"
		pacman -Syf $COREPKGS -r "$CHROOTDIR" --noconfirm --config $_F_makepkg_pacconf
		if [ "$?" != "0" ]; then
			error "Failed to build chroot environment."
			chroot_umount
			msg "Removing lock file..."
			rm -f $CHROOTDIR/var/tmp/fst/lock $_F_makepkg_pacconf
			exit 1
		fi
		rm -f $_F_makepkg_pacconf
	else
		msg "Updating the chroot environment"
		# run pacman -Su twice in case pacman updated
		pacman -Syu -r "$CHROOTDIR" --noconfirm --config $CHROOTDIR/etc/pacman.conf && \
			pacman -Su -r "$CHROOTDIR" --noconfirm --config $CHROOTDIR/etc/pacman.conf
		if [ "$?" != "0" ]; then
			error "Failed to update chroot environment."
			chroot_umount
			msg "Removing lock file..."
			rm -f $CHROOTDIR/var/tmp/fst/lock
			exit 1
		fi
	fi
	# why is this necessary?
	chmod 1777 $CHROOTDIR/tmp
	
	msg "Copying config files to chroot"
	cp -pf /etc/pacman.d/* $CHROOTDIR/etc/pacman.d >/dev/null &
	cp -pf /etc/makepkg.conf $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/resolv.conf $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/passwd $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/shadow $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/group $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/hosts $CHROOTDIR/etc > /dev/null &
	chmod 644 $CHROOTDIR/etc/sudoers
	echo "fst ALL=(ALL)       NOPASSWD: ALL" >$CHROOTDIR/etc/sudoers
	chmod 440 $CHROOTDIR/etc/sudoers
	cp -Ppf /etc/localtime $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/services $CHROOTDIR/etc > /dev/null &
	if [ "$?" != "0" ]; then
		error "An error occurred while attempting to copy config files to chroot."
		chroot_umount
		exit 1
	fi
	# to make Finclude work
	[ -d $CHROOTDIR/var/tmp/fst/include/ ] || mkdir -p $CHROOTDIR/var/tmp/fst/include/
	i=`pwd`
	while true
	do
		if [ -e "$i/_darcs" ]; then
			break
		elif [ "$i" == "" ]; then
			break
		fi
		i=`echo $i|sed 's|\(.*\)/.*|\1|'`
	done
	if darcs --commands 2>&1|grep -q add && [ "$i" -a -d "$i"/source/include ]; then
		cp $i/source/include/* $CHROOTDIR/var/tmp/fst/include/
	elif [ -d $fst_root/$reponame/source/include ]; then
		cp $fst_root/$reponame/source/include/* $CHROOTDIR/var/tmp/fst/include/
	fi

	msg "Copying $pkgname's buildscript to chroot"
	cp -a * $CHROOTDIR/var/tmp/fst/
	chown -R fst:users $CHROOTDIR/var/tmp/fst
	
	if [ ! -x  /usr/sbin/chroot ]; then
		error "chroot was not found."
	else
		msg "Entering chroot environment"
		if [ ! "`check_option NOFAKEROOT`" ]; then
			/usr/sbin/chroot $CHROOTDIR \
				/bin/su - fst -c "$0 --inchroot -S $ARGLIST"
		else
			echo "cd /var/tmp/fst/; $0 --inchroot -s $ARGLIST" | \
				/usr/sbin/chroot $CHROOTDIR /bin/sh
		fi
	fi

	# save the build log if necessary
	if [ -f $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log ]; then
		mv $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log ./
	fi

	if [ -f $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm ]; then
		mv $CHROOTDIR/var/tmp/fst/*-${pkgver}-${pkgrel}-${CARCH}.fpm $PKGDEST
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %u:%g FrugalBuild` \
				*-${pkgver}-${pkgrel}-${CARCH}.fpm
		fi
		# copy back the buildscript, maybe modified
		cp $CHROOTDIR/var/tmp/fst/FrugalBuild ./
		rm -rf $CHROOTDIR/var/tmp/fst/*
		chroot_clean
		ret=0
	else
		ret=1
	fi

	chroot_umount
	rm -f $CHROOTDIR/var/tmp/fst/lock
	exit $ret
fi

# Enter the fakeroot environment if necessary.  This will call the makepkg script again
# as the fake root user.  We detect this by passing a sentinel option (-F) to makepkg
if [ "`id -u`" != "0" ]; then
	if [ "$USE_FAKEROOT" = "y" -o "$USE_FAKEROOT" = "Y" ]; then
		if [ `type -p fakeroot` ]; then
			msg "Entering fakeroot environment"
			if [ "$INCHROOT" != "1" ]; then
				fakeroot -- $0 -F $ARGLIST
			else
				fakeroot -- $0 -F --inchroot $ARGLIST
			fi
			exit $?
		else
			warning "Fakeroot is not installed.  Building as an unprivileged user"
			plain "will result in non-root ownership of the packaged files."
			plain "Install the fakeroot package to correctly build as a non-root"
			plain "user."
			plain ""
			sleep 1
		fi
	else
		warning "Running makepkg as an unprivileged user will result in non-root"		
		plain "ownership of the packaged files.  Try using the fakeroot"
		plain "environment.  (USE_FAKEROOT=y in makepkg.conf)"
		plain ""
		sleep 1
	fi
fi

# some applications (eg, blackbox) will not build with some languages
unset LC_ALL LANG
msg "Making package: $pkgname $pkgver-$pkgrel (`date`)"

unset deplist makedeplist
if [ `type -p pacman` -a "$NODEPS" = "0" ]; then
	msg "Checking Runtime Dependencies..."
	deplist=`checkdeps ${depends[@]}`
	handledeps $deplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	# check deps again to make sure they were resolved
	deplist=`checkdeps ${depends[@]}`
	if [ ! -z "$deplist" ]; then
		error "Failed to install missing dependencies."
		exit 1
	fi
	msg "Checking Buildtime Dependencies..."
	makedeplist=`checkdeps ${makedepends[@]}`
	handledeps $makedeplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
elif [ "$NODEPS" = "1" ]; then
	warning "skipping dependency checks."
else
	warning "pacman was not found in PATH. skipping dependency checks."
fi

cd $startdir

# version checking
if [ "$NOUP2DATE" = "0" ]; then
	msg "Checking for newer version..."
	if echo "$up2date"|grep -q " "; then
		cmd=`echo "$up2date"|sed 's/^\([^ ]*\) .*/\1/'`
		if type -p $cmd &>/dev/null; then
			up2date=`eval "$up2date"`
		else
			warning "The $cmd program is missing.  Cannot check for newer version!"
			up2date=""
			sleep 1
		fi
	fi
	if [ -z "$up2date" ]; then
		warning "Version checking informations are missing. Cannot check for newer version."
	else
		if [ "$pkgver" != "$up2date" ]; then
			echo "   FAILED" >&2
			error "Newer version available! ($pkgver < $up2date)"
			exit 1
		else
		echo "   Passed" >&2
		fi
	fi
fi

# estimate build time
if grep -i -q "^# Compiling Time: [~0-9\.]\+ SBU$" $BUILDSCRIPT && \
	[ ! -z "$SBU" ] && [ "$SBU" != "1" ]; then
	pkgsbu=`grep -i "^# Compiling time: [~0-9\.]\+ SBU$" $BUILDSCRIPT|sed 's/^# Compiling [Tt]ime: ~*\([0-9\.]\+\) SBU$/\1/'`
	secs=`echo "$pkgsbu*$SBU"|bc /dev/stdin|sed 's/\.[0-9]*$//'`
	if [ $secs -ge 3600 ]; then
		hrs=`echo $(($secs/3600))`
		secs=`echo $(($secs%3600))`
		mins=`echo $(($secs/60))`
		secs=`echo $(($secs%60))`
	elif [ $secs -ge 60 ]; then
		mins=`echo $(($secs/60))`
		secs=`echo $(($secs%60))`
	fi
	if [ ! -z "$hrs" ]; then
		[ $hrs -gt 1 ] && hrs="$hrs hours " || hrs="$hrs hour "
	fi
	if [ ! -z "$mins" ]; then
		[ $mins -gt 1 ] && mins="$mins minutes " || mins="$mins minute "
	fi
	if [ ! -z "$secs" ]; then
		[ $secs -gt 1 ] && secs="$secs seconds " || secs="$secs second "
	fi
	msg "Estimated build time: $hrs$mins$secs"
fi

# retrieve sources
msg "Retrieving Sources..."
mkdir -p src
cd $startdir/src
for netfile in "${source[@]}" "${signatures[@]}"; do
	[ -z "$netfile" ] && continue
	file=`strip_url "$netfile"`
	if [ -f "../$file" ]; then
		msg "    Found $file in build dir"
		cp "../$file" .
	elif [ -f "/var/cache/pacman/src/$file" ]; then
		msg "    Using local copy of $file"
		cp "/var/cache/pacman/src/$file" .
	else
		proto=`echo "$netfile" | sed 's|://.*||'`
		if [ "$proto" != "ftp" -a "$proto" != "http" -a "$proto" != "https" ]; then
			error "$netfile was not found in the build directory and is not a proper URL."
			msg "Aborting..."
			exit 1
		fi
		msg "    Downloading $file"
		$FTPAGENT "$netfile" 2>&1
		if [ ! -f "$file" ]; then
			error "Failed to download $file"
			msg "Aborting..."
			exit 1
		fi
		if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
			mkdir -p /var/cache/pacman/src && cp "$file" /var/cache/pacman/src
		else
			cp "$file" ..
		fi
	fi
done

if [ "$GENMD5" = "0" -a "$GENSHA1" = "0" ]; then
	if [ "$NOEXTRACT" = "1" ]; then
		warning "Skipping source extraction       -- using existing src/ tree"
		warning "Skipping source integrity checks -- using existing src/ tree"
	else
		# SHA1 validation
		if [ ${#sha1sums[@]} -eq ${#source[@]} ]; then
			if [ `type -p sha1sum` ]; then
				msg "Validating source files with SHA1sums"
				errors=0
				idx=0
				for netfile in "${source[@]}"; do
					file=`strip_url "$netfile"`
					echo -n "    $file ... " >&2
					echo "${sha1sums[$idx]}  $file" | sha1sum -c - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						echo "FAILED" >&2
						errors=1
					else
						echo "Passed" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The sha1sum program is missing.  Cannot verify source files!"
				sleep 1
			fi
		# MD5 validation
		elif [ ${#md5sums[@]} -eq ${#source[@]} ]; then
			if [ `type -p md5sum` ]; then
				msg "Validating source files with MD5sums"
				errors=0
				idx=0
				for netfile in "${source[@]}"; do
					file=`strip_url "$netfile"`
					echo -n "    $file ... " >&2
					echo "${md5sums[$idx]}  $file" | md5sum -c - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						echo "FAILED" >&2
						errors=1
					else
						echo "Passed" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The md5sum program is missing.  Cannot verify source files!"
				sleep 1
			fi
		elif [ ${#signatures[@]} -ne ${#source[@]} ]; then
			warning "MD5sums, SHA1sums and signatures are missing or incomplete."
			plain "Cannot verify source integrity."
		fi
		# gpg validation
		if [ ${#signatures[@]} -eq ${#source[@]} ]; then
			if [ `type -p gpg` ]; then
				if [ ! -d ~/.gnupg ]; then
					msg "Configuring gpg..."
					gpg --list-keys
					echo "keyserver-options auto-key-retrieve" >>~/.gnupg/gpg.conf
				fi
				msg "Validating source files with gpg"
				errors=0
				idx=0
				for netfile in "${source[@]}"; do
					file=`strip_url "$netfile"`
					sig=`strip_url "${signatures[$idx]}"`
					echo -n "    $file ... " >&2
					if [ ! -z "$sig" ]; then
						gpg --batch --verify $sig $file >/dev/null 2>&1
						if [ $? -ne 0 ]; then
							echo "FAILED" >&2
							errors=1
						else
							echo "Passed" >&2
						fi
					else
						echo "Skipping" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The gpg program is missing.  Cannot verify source files!"
				sleep 1
			fi
		fi

		# extract sources
		msg "Extracting Sources..."
		for netfile in "${source[@]}"; do
			unziphack=0
			file=`strip_url "$netfile"`
			unset cmd
			case "$file" in
				*.tar.gz|*.tar.Z|*.tgz)
				cmd="tar --use-compress-program=gzip -xf" ;;
				*.tar.bz2|*.tbz2)
				cmd="tar --use-compress-program=bzip2 -xf" ;;
				*.tar)
				cmd="tar -xf" ;;
				*.zip)
				unziphack=1
				cmd="unzip -qqo" ;;
				*.gz)
				cmd="gunzip" ;;
				*.bz2)
				cmd="bunzip2" ;;
			esac
			if [ "$cmd" != "" ]; then
				msg "    $cmd $file"
				$cmd "$file"
				if [ $? -ne 0 ]; then
					# unzip will return a 1 as a warning, it is not an error
					if [ "$unziphack" != "1" -o $? -ne 1 ]; then
						error "Failed to extract $file"
						msg "Aborting..."
						exit 1
					fi
				fi
			fi
		done
	fi
else
# generate md5 hashes
	if [ "$GENMD5" = "1" ]; then
		if [ ! `type -p md5sum` ]; then
			error "Cannot find the md5sum program."
			exit 1
	fi
		msg "Generating MD5sums for source files"
		plain ""
		ct=0
		newline=0
		numsrc=${#source[@]}
		for netfile in "${source[@]}"; do
			file=`strip_url $netfile`
			sum=`md5sum $file | cut -d' ' -f 1`
			if [ $ct -eq 0 ]; then
				echo -n "md5sums=("
			else
				if [ $newline -eq 0 ]; then
					echo -n "         "
				fi
			fi
			echo -n "'$sum'"
			ct=$(($ct+1))
			if [ $ct -eq $numsrc ]; then
				echo ')'
			else
				if [ $newline -eq 1 ]; then
					echo '\'
					newline=0
				else
					echo -n ' '
					newline=1
				fi
			fi
		done
		plain ""
		exit 0
	# generate sha1 hashes
	elif [ "$GENSHA1" = "1" ]; then
		if [ ! `type -p sha1sum` ]; then
			error "Cannot find the sha1sum program."
			exit 1
		fi
		msg "Generating SHA1sums for source files"
		plain ""
		ct=0
		newline=0
		numsrc=${#source[@]}
		for netfile in "${source[@]}"; do
			file=`strip_url "$netfile"`
			sum=`sha1sum "$file" | cut -d' ' -f 1`
			if [ $ct -eq 0 ]; then
				echo -n "sha1sums=("
			else
				echo -ne "\t  "
			fi
			echo -n "'$sum'"
			ct=$(($ct+1))
			if [ $ct -eq $numsrc ]; then
				echo ')'
			else
				echo ' \'
				newline=0
			fi
		done
	plain ""
	exit 0
    fi
fi

if [ "`id -u`" = "0" ]; then
	# chown all source files to root.root
	chown -R root.root $startdir/src
fi

# check for existing pkg directory
if [ -d $startdir/pkg ]; then
	msg "Removing existing pkg/ directory..."
	rm -rf $startdir/pkg*
fi
mkdir -p $startdir/pkg

if [ "$NOBUILD" = "1" ]; then
	msg "Sources are ready."
	exit 0
fi

# use distcc if requested
if [ "$DISTCC" = "y" -a -d /usr/lib/distcc/bin ]; then
	export PATH=/usr/lib/distcc/bin:$PATH
	FCC="distcc $FCC"
	if [ "$INCHROOT" = "1" ]; then
		[ -d /var/tmp/fst/.distcc ] || mkdir /var/tmp/fst/.distcc
		export DISTCC_DIR=/var/tmp/fst/.distcc
	fi
fi

# use ccache if it's available
if [ "$NOCCACHE" = "0" -a -d /usr/lib/ccache/bin ]; then
	export PATH=/usr/lib/ccache/bin:$PATH
	FCC="ccache $FCC"
	install -d -m 2775 /var/cache/ccache/$pkgname
	export CCACHE_DIR=/var/cache/ccache/$pkgname
	export CCACHE_NOLINK=1
	export CCACHE_UMASK=002
fi

# build
msg "Starting build()..."
BUILDLOG=${startdir}/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
stime=`date +%s`
build 2>&1 | tee "${BUILDLOG}"
if [ ${PIPESTATUS[0]} -gt 0 ]; then
	error "Build Failed.  Aborting..."
	exit 2
fi

# count sbu
if [ "$SBU" == "1" ]; then
	# $SBU not yet set
	msg "Elapsed Time: $(($(date +%s)-$stime)) seconds"
elif [ ! -z "$SBU" ]; then
	if [ `type -p bc` ]; then
		pkgsbu=`echo -e "scale=2\n$(($(date +%s)-$stime))/$SBU"|bc /dev/stdin|sed 's/^\./0./'`
		msg "Elapsed Time: $pkgsbu SBU"
		echo "Elapsed Time: $pkgsbu SBU">> "${BUILDLOG}"
	else
		warning "The bc program is missing.  Cannot count SBU!"
	fi
fi

# documentation
msg "Preparing package documentation..."
cd $startdir
if [ -d pkg/usr/doc ]; then
	mkdir -p pkg/usr/share/doc
	cp -a pkg/usr/doc/* pkg/usr/share/doc/
	rm -rf pkg/usr/doc
fi
if [ ! "`check_option NODOCS`" -a "$NODOCS" = "0" ]; then
	mkdir -p pkg/usr/share/doc/$pkgname-$pkgver
	for i in `find src -maxdepth 2 -name ANNOUNCE -o -name AUTHORS -o -name *BUGS* -o -name CHANGES -o -name CONFIGURATION -o -name *COPYING* -o -name *COPYRIGHT* -o -name CREDITS -o -name ChangeLog -o -name Changelog -o -name CHANGELOG -o -name CONTRIBUTORS -o -name *FAQ* -o -name FEATURES -o -name FILES -o -name HACKING -o -name History -o -name HISTORY -o -name INSTALL* -o -name LICENSE -o -name LSM -o -name MANIFEST -o -name NEWS -o -name *README* -o -name *Readme* -o -name SITES -o -name *RELEASE* -o -name RELNOTES -o -name THANKS -o -name TIPS -o -name TODO -o -name VERSION -o -name CONFIGURATION* -o -name GPLLicense`
	do
		cp -a $i pkg/usr/share/doc/$pkgname-$pkgver/
	done
fi

# remove /usr/share/doc/$pkgname-$pkgver directory if empty
if [ -d pkg/usr/share/doc/$pkgname-$pkgver ]; then
	if [ -z "`ls -1 pkg/usr/share/doc/$pkgname-$pkgver`" ]; then
		rmdir pkg/usr/share/doc/$pkgname-$pkgver
	fi
fi

# remove /usr/share/doc/ directory if empty
if [ -d pkg/usr/share/doc ]; then
	if [ -z "`ls -1 pkg/usr/share/doc`" ]; then
		rmdir pkg/usr/share/doc
	fi
fi

# move /usr/share/info files to /usr/info
if [ -d pkg/usr/share/info ]; then
	mkdir -p pkg/usr/info
	cp -a pkg/usr/share/info/* pkg/usr/info/
	rm -rf pkg/usr/share/info
fi

# move /usr/share/man files to /usr/man
if [ -d pkg/usr/share/man ]; then
	mkdir -p pkg/usr/man 
	cp -a pkg/usr/share/man/* pkg/usr/man/
	rm -rf pkg/usr/share/man
fi

# remove /usr/share directory if empty
if [ -d pkg/usr/share ]; then
	if [ -z "`ls -1 pkg/usr/share`" ]; then
		rm -r pkg/usr/share
	fi
fi

# compress man pages
msg "Compressing man pages..."
find $startdir/pkg*/{usr{,/local,/share},opt/*}/man -type f 2>/dev/null | while read i ; do
	ext="${i##*.}"
	fn="${i##*/}"
	if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
		# update symlinks to this manpage
		find $startdir/pkg/{usr{,/local,/share},opt/*}/man -lname "$fn" 2> /dev/null | while read ln ; do
			rm -f "$ln"
			ln -sf "${fn}.gz" "${ln}.gz"
		done
		# compress the original
		gzip -9 "$i"
	fi
done

# strip binaries
if [ ! "`check_option NOSTRIP`" -a "$NOSTRIP" = "0" ]; then
	msg "Stripping debugging symbols from libraries..."
	find pkg*/{,usr,usr/local,opt/*}/lib -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip --strip-debug '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
	msg "Stripping symbols from binaries..."
	find pkg*/{,usr,usr/local,opt/*}/{bin,sbin} -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
fi

# get some package meta info
builddate=`LC_ALL= ; LANG= ; date -u "+%a %b %e %H:%M:%S %Y"`
if [ "$PACKAGER" != "" ]; then
	packager="$PACKAGER"
else
	packager="Frugalware Linux (http://frugalware.org)"
fi

create_pkg $pkgname
if [ ! -z "$subpkgs" ]; then
	goodsubpkgs=1
	if [ "${#subdescs[@]}" != 0 ] && [ "${#subdescs[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#sublicense[@]}" != 0 ] && [ "${#sublicense[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subreplaces[@]}" != 0 ] && [ "${#subreplaces[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subgroups[@]}" != 0 ] && [ "${#subgroups[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subdepends[@]}" != 0 ] && [ "${#subdepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subrodepends[@]}" != 0 ] && [ "${#subrodepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subremoves[@]}" != 0 ] && [ "${#subremoves[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subconflicts[@]}" != 0 ] && [ "${#subconflicts[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subprovides[@]}" != 0 ] && [ "${#subprovides[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subbackup[@]}" != 0 ] && [ "${#subbackup[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subinstall[@]}" != 0 ] && [ "${#subinstall[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#suboptions[@]}" != 0 ] && [ "${#suboptions[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ $goodsubpkgs -eq 1 ]; then
		i=0
		for subpkg in "${subpkgs[@]}"
		do
			unset pkgdesc license replaces groups depends rodepends removes conflicts provides backup install
			unset options pkgdesc_localized
			pkgdesc="${subdescs[$i]}"
			pkgdesc_localized="${subdescs_localized[$i]}"
			license="${sublicense[$i]}"
			replaces="${subreplaces[$i]}"
			groups="${subgroups[$i]}"
			depends="${subdepends[$i]}"
			rodepends="${subrodepends[$i]}"
			removes="${subremoves[$i]}"
			conflicts="${subconflicts[$i]}"
			provides="${subprovides[$i]}"
			backup="${subbackup[$i]}"
			install="${subinstall[$i]}"
			options="${suboptions[$i]}"
			create_pkg $subpkg
			i=$(($i+1))
		done
	else
		warning "Subpackage infos are incomplete. Cannot create subpackages."
	fi
fi

cd $startdir
if [ "$CLEANUP" = "1" ]; then
	msg "Cleaning up..."
	rm -rf src pkg* filelist
fi

if [ "$RMDEPS" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" -a \( ! -z "$deplist" -o ! -z "$makedeplist" \) ]; then
	msg "Removing installed dependencies..."
	pacman $PACMAN_OPTS -R $makedeplist $deplist
elif [ "$RMDEPS" = "1" -a "$DEP_SUDO" = "1" ]; then
	msg "Removing installed dependencies..."
	if [ "$INFAKEROOT" = "1" ]; then
		FAKEROOTKEY2=$FAKEROOTKEY
		unset FAKEROOTKEY
	fi
	sudo pacman $PACMAN_OPTS -R $makedeplist $deplist
	if [ "$INFAKEROOT" = "1" ]; then
		export FAKEROOTKEY=$FAKEROOTKEY2
		unset FAKEROOTKEY2
	fi
fi

# check optimization and write it to $BUILDSCRIPT
msg "Checking for optimization..."
if grep -q -- "\($CFLAGS\|$CXXFLAGS\)" "${BUILDLOG}" ; then
	if ! grep -q "# optimization" "${BUILDSCRIPT}" ; then
		echo -e "\n# optimization OK" >> "${BUILDSCRIPT}"
	fi
else
	warning "This package isn't ${CARCH} optimized!"
fi

# remove build log
if [ "${LOGGING}" == "0" ] ; then
	msg "Removing build log..."
	rm -f "${BUILDLOG}"
fi

# update last mod line
if [ "$NOLASTMOD" = "0" ]; then
	sed -i "s/^\(# Last modified: \).*/\1`date -R`/i" $BUILDSCRIPT
fi

msg "Finished making: $pkgname  (`date`)"

install_pkg

exit 0
