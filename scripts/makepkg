#!/bin/bash
# 
#   makepkg
#  
#   Copyright (c) 2002-2005 by Judd Vinet <jvinet@zeroflux.org>
#  
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
# 
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#  
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, 
#   USA.
#

myver='2.9.8'
startdir=`pwd`
PKGDEST=$startdir
USE_COLOR="n"

# Options
BUILDSCRIPT="./FrugalBuild"
CLEANUP=0
CLEANCACHE=0
DEP_BIN=0
DEP_SRC=0
DEP_SUDO=0
FORCE=0
GENSHA1=0
GENMD5=0
INSTALL=0
DOWNLOAD=""
NOLASTMOD=0
NOBUILD=0
NOCCACHE=0
NODEPS=0
NOEXTRACT=0
NOSTRIP=0
RMDEPS=0
CHROOT=0
LOGGING=0
NOUP2DATE=0
GZIP=0
NOSTRIP=0
NODOCS=0

# Frugalware extensions to makepkg
[ -e /usr/lib/frugalware/fwmakepkg ] && . /usr/lib/frugalware/fwmakepkg

# repoman.conf for $fst_root
[ -f /etc/repoman.conf ] && source /etc/repoman.conf

# makepkg configuration
[ -f /etc/makepkg.conf ] && source /etc/makepkg.conf

INFAKEROOT=
if [ "$1" = "-F" ]; then
	INFAKEROOT=1
	shift
fi

INCHROOT=
if [ "$1" = "--inchroot" ]; then
	INCHROOT=1
	shift
fi

### SUBROUTINES ###

plain() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "    \033[1;1m$1\033[1;0m" >&2
	else
		echo "    $1" >&2
	fi
}
msg() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;32m==>\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> $1" >&2
	fi
}
warning() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;33m==> WARNING:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> WARNING: $1" >&2
	fi
}
error() {
	if [ "$USE_COLOR" = "Y" -o "$USE_COLOR" = "y" ]; then
		echo -e "\033[1;31m==> ERROR:\033[1;0m \033[1;1m$1\033[1;0m" >&2
	else
		echo "==> ERROR: $1" >&2
	fi
}

strip_url() {
	echo $1 | sed 's|^.*://.*/||g'
}

check_option() {
	local i
	for i in ${options[@]}; do
		local uc=`echo $i | tr [:lower:] [:upper:]`
		local lc=`echo $i | tr [:upper:] [:lower:]`
		if [ "$uc" = "$1" -o "$lc" = "$1" ]; then
			echo $1
			return
		fi
	done
}

checkdeps() {
	local missdep=""
	local deplist=""

	missdep=`pacman -T $*`
	ret=$?
	if [ "$ret" != "0" ]; then
		if [ "$ret" = "127" ]; then
			msg "Missing Dependencies:"
			msg ""
			nl=0
			for dep in $missdep; do
				echo -ne "$dep " >&2
				if [ "$nl" = "1" ]; then
					nl=0
					echo -ne "\n" >&2
					# add this dep to the list
					depname=`echo $dep | sed 's|=.*$||' | sed 's|>.*$||' | sed 's|<.*$||'`
					deplist="$deplist $depname"
					continue
				fi
				nl=1
			done
			msg ""
		else
			error "pacman returned a fatal error."
			exit 1
		fi
	fi
	echo $deplist
}

handledeps() {
	local missingdeps=0
	local deplist="$*"
	local haveperm=0
	if [ \( "`id -u`" = "0" -a "$INFAKEROOT" != "1" \) -o "$DEP_SUDO" = 1 ]; then
		haveperm=1
	fi

	if [ "$deplist" != "" -a $haveperm -eq 1 ]; then
		if [ "$DEP_BIN" = "1" ]; then
			# install missing deps from binary packages (using pacman -S)
			msg "Installing missing dependencies..."
			pacman -D $deplist
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
			# TODO: check deps again to make sure they were resolved
		elif [ "$DEP_SUDO" = "1" ]; then
			# install missing deps from binary packages (using pacman -S and sudo)
			msg "Installing missing dependencies..."
			if [ "$INFAKEROOT" = "1" ]; then
				# kinda hacky, but we need to make pacman think that we're NOT
				# in fakeroot so it will go ahead and install the dependencies.
				FAKEROOTKEY2=$FAKEROOTKEY
				unset FAKEROOTKEY
			fi
			sudo pacman -D $deplist
			if [ "$?" = "127" ]; then
				error "Failed to install missing dependencies."
				exit 1
			fi
			if [ "$INFAKEROOT" = "1" ]; then
				export FAKEROOTKEY=$FAKEROOTKEY2
				unset FAKEROOTKEY2
			fi
			# TODO: check deps again to make sure they were resolved
		elif [ "$DEP_SRC" = "1" ]; then
			# install missing deps by building them from source.
			# we look for each package name in $fst_root and build it.
			if [ "$fst_root" = "" ]; then
				error "The fst_root environment variable is not defined, check your /etc/repoman.conf!"
				exit 1
			fi
			# TODO: handle version comparators (eg, glibc>=2.2.5)
			msg "Building missing dependencies..."
			for dep in $deplist; do
				candidates=`find $fst_root -type d -name "$dep"`
				if [ "$candidates" = "" ]; then
					error "Could not find \"$dep\" under $fst_root"
					exit 1
				fi
				success=0
				for pkgdir in $candidates; do
					if [ -f $pkgdir/FrugalBuild ]; then
						cd $pkgdir
						if [ "$RMDEPS" = "1" ]; then
							makepkg -i -c -b -r -w $PKGDEST
						else
							makepkg -i -c -b -w $PKGDEST
						fi
						if [ $? -eq 0 ]; then
							success=1
							break
						fi
					fi
				done
				if [ "$success" = "0" ]; then
					error "Failed to build \"$dep\""
					exit 1
				fi
			done
			# TODO: check deps again to make sure they were resolved
		else
			missingdeps=1
		fi
	# rerun any additional sh scripts found in /etc/profile.d/
	for i in /etc/profile.d/*.sh
	do
		if [ -x $i ]; then
			. $i &>/dev/null
		fi
	done
	elif [ "$deplist" != "" -a $haveperm -eq 0 ]; then
		if [ "$DEP_SRC" = "1" -o "$DEP_BIN" = "1" ]; then
			warning "Cannot auto-install missing dependencies as a normal user without sudo!"
			plain "Run makepkg as root or with -S to resolve dependencies automatically."
		fi
		missingdeps=1
	fi
	return $missingdeps
}

usage() {
	echo "makepkg version $myver"
	echo "usage: $0 [options]"
	echo "options:"
	echo "  -a, --searchdeps Search for package dependencies automatically"
	echo "  -b, --builddeps  Build missing dependencies from source"
	echo "  -B, --noccache   Do not use ccache during build"
	echo "  -c, --clean      Clean up work files after build"
	echo "  -C, --cleancache Clean up source files from the cache"
	echo "  -d, --nodeps     Skip all dependency checks"
	echo "  -e, --noextract  Do not extract source files (use existing src/ dir)"
	echo "  -f, --force      Overwrite existing package"
	echo "  -g, --gensha1    Generate SHA1sums for source files"
	echo "  -G, --genmd5     Generate MD5sums for source files"
	echo "  -h, --help       This help"
	echo "  -i, --install    Install package after successful build"
	echo "  -j <jobs>        Set MAKEFLAGS to \"-j<jobs>\" before building"
	echo "  -k, --logging    Logging package build process"
	echo "  -l <pkgname>     Download buildscipts before building"
	echo "  -L, --nolastmod  Do not update the \"Last modified\" line"
	echo "  -m, --nocolor    Disable colorized output messages"
	echo "  -n, --nostrip    Do not strip binaries/libraries"
	echo "  -o, --nobuild    Download and extract files only"
	echo "  -p <buildscript> Use an alternate build script (instead of FrugalBuild)"
	echo "  -r, --rmdeps     Remove installed dependencies after a successful build"
	echo "  -R, --chroot     Build the package in a chroot environment"
	echo "  -s, --syncdeps   Install missing dependencies with pacman"
	echo "  -S, --sudosync   Install missing dependencies with pacman and sudo"
	echo "  -u, --noup2date  Do not check for newer version"
	echo "  -w <destdir>     Write package to <destdir> instead of the working dir"
	echo "  --gzip           Use gzip compression for a package instead of bzip2"
	echo
	echo "  if -p is not specified, makepkg will look for a FrugalBuild"
	echo "  file in the current directory."
	echo
}

chroot_umount() {
    msg "Attempting to umount chroot directories..."
    umount $CHROOTDIR/proc >/dev/null
    umount $CHROOTDIR/sys >/dev/null
    umount $CHROOTDIR/dev >/dev/null
    umount $CHROOTDIR/var/cache/pacman >/dev/null
    umount $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to umount chroot directories."
	exit 1
    fi
    msg "Successfully umounted chroot directories."
}

chroot_mount() {
    msg "Attempting to mount chroot directories..."
    mount -t proc none $CHROOTDIR/proc >/dev/null &
    mount -t sysfs none $CHROOTDIR/sys >/dev/null &
    mount -o bind /dev $CHROOTDIR/dev >/dev/null &
    mount -o bind /var/cache/pacman $CHROOTDIR/var/cache/pacman >/dev/null &
    mount -o bind /var/cache/ccache/$pkgname \
    $CHROOTDIR/var/cache/ccache/$pkgname >/dev/null &
    if [ "$?" != "0" ]; then
	error "An error occurred while attempting to mount chroot directories."
	exit 1
    fi
    msg "Successfully mounted chroot directories."
}

chroot_clean()
{
	if [ "$CHROOT" = "1" ]; then
		msg "Cleaning chroot."
		rm -rf $CHROOTDIR/var/tmp/fst/*
		msg "Removing unnecessary packages."
		for i in "$COREPKGS"
		do
			corelist="$corelist `pacman -r $CHROOTDIR -Sg $i|grep -v '^\w'`"
		done
		for i in `pacman -r $CHROOTDIR -Q|sed 's/\([^ ]*\) .*/\1/'`
		do
			if ! echo $corelist |grep -q $i; then
				removelist="$removelist $i"
			fi
		done
		if [ ! -z "$removelist" ]; then
			pacman -r $CHROOTDIR -Rcn $removelist --noconfirm
			if [ "$?" != "0" ]; then
				error "Failed to remove packages."
				exit 1
			fi
		fi
	fi
}

create_pkg()
{
	msg "Generating $1-$pkgver-$pkgrel-$CARCH.fpm"
	# write the .PKGINFO file
	echo "    .PKGINFO file... " >&2
	if [ "$1" = "$pkgname" ]; then
		cd $startdir/pkg
	else
		cd $startdir/pkg.$1
	fi
	size=`du -cb . | tail -n 1 | awk '{print $1}'`
	echo "# Generated by makepkg $myver" >.PKGINFO
	echo -n "# " >>.PKGINFO
	date >>.PKGINFO
	echo "pkgname = $1" >>.PKGINFO
	echo "pkgver = $pkgver-$pkgrel" >>.PKGINFO
	echo "pkgdesc = $pkgdesc" >>.PKGINFO
	echo "url = $url" >>.PKGINFO
	echo "builddate = $builddate" >>.PKGINFO
	echo "packager = $packager" >>.PKGINFO
	echo "size = $size" >>.PKGINFO
	if [ "$CARCH" != "" ]; then
		echo "arch = $CARCH" >>.PKGINFO
	fi

	for it in ${license[@]}; do
		echo "license = $it" >>.PKGINFO
	done
	for it in ${replaces[@]}; do
		echo "replaces = $it" >>.PKGINFO
	done
	for it in ${groups[@]}; do
		echo "group = $it" >>.PKGINFO
	done
	for it in ${depends[@]}; do
		echo "depend = $it" >>.PKGINFO
	done
	for it in ${rodepends[@]}; do
		echo "depend = $it" >>.PKGINFO
	done
	for it in ${removes[@]}; do
		echo "remove = $it" >>.PKGINFO
	done
	for it in ${conflicts[@]}; do
		echo "conflict = $it" >>.PKGINFO
	done
	for it in ${provides[@]}; do
		echo "provides = $it" >>.PKGINFO
	done
	for it in ${backup[@]}; do
		echo "backup = $it" >>.PKGINFO
	done

	# check for an install script
	if [ "$install" == "" ]; then
		[ -e $startdir/$1.install ] && install=$1.install
	fi
	if [ "$install" != "" ]; then
		echo "    .INSTALL file... " >&2
		cp $startdir/$install .INSTALL
	fi

	if [ -f $startdir/Changelog ]; then
		echo "    .CHANGELOG file... " >&2
		cp $startdir/Changelog .CHANGELOG
	fi

	# build a filelist
	echo "    .FILELIST file... " >&2
	tar cvf /dev/null * | sort >.FILELIST

	# tar it up
	echo "    Compressing package... " >&2
	unset extra
	if [ -f .INSTALL ]; then
		extra=".INSTALL"
	fi
	if [ -f .CHANGELOG ]; then
		extra="$extra .CHANGELOG"
	fi

	if [ "$GZIP" == "1" ]; then
		tarargs="czvf"
		warning "Using gzip compression - this is not optimal!"
	else
		tarargs="cjvf"
	fi

	if [ "$INCHROOT" != "1" ]; then
		tar $tarargs $PKGDEST/$1-$pkgver-$pkgrel-$CARCH.fpm .PKGINFO .FILELIST \
		$extra * | sort >../filelist
	else
		tar $tarargs ../$1-$pkgver-$pkgrel-$CARCH.fpm .PKGINFO .FILELIST \
			$extra * | sort >../filelist
	fi

	if [ "$SEARCHDEPS" == "1" ]; then
		if [ -x /usr/bin/chkdep ]; then
			msg "Searching for depends..."
			warning "Do not use this information without thinking!"
			chkdep -d ./ -n $1 -i
		else
			warning "Chkdep is not installed and is required to search depends."
			plain "Install the pacman-tools package, wich contains chkdep."
			plain ""
			sleep 1
		fi
	fi
}

ARGLIST=$@

while [ "$#" -ne "0" ]; do
	case $1 in
		--searchdeps) SEARCHDEPS=1 ;;
		--clean)      CLEANUP=1 ;;
		--cleancache) CLEANCACHE=1 ;;
		--syncdeps)   DEP_BIN=1 ;;
		--sudosync)   DEP_SUDO=1 ;;
		--builddeps)  DEP_SRC=1 ;;
		--noccache)   NOCCACHE=1 ;;
		--nodeps)     NODEPS=1 ;;
		--noextract)  NOEXTRACT=1 ;;
		--install)    INSTALL=1 ;;
		--nolastmod)  NOLASTMOD=1 ;;
		--force)      FORCE=1 ;;
		--nostrip)    NOSTRIP=1 ;;
		--nobuild)    NOBUILD=1 ;;
		--nocolor)    USE_COLOR="n" ;;
		--gensha1)    GENSHA1=1 ;;
		--genmd5)     GENMD5=1 ;;
		--rmdeps)     RMDEPS=1 ;;
		--chroot)     CHROOT=1 ;;
		--noup2date)  NOUP2DATE=1 ;;
		--logging)    LOGGING=1 ;;
		--gzip)       GZIP=1 ;;
		--help)
			usage
			exit 0
			;;
		--*)
			usage
			exit 1
			;;
		-*)
			while getopts "abBcCdefgGhij:kl:Lmnop:urRsSw:-" opt; do
				case $opt in
					a) SEARCHDEPS=1 ;;
					b) DEP_SRC=1 ;;
					B) NOCCACHE=1 ;;
					c) CLEANUP=1 ;;
					C) CLEANCACHE=1 ;;
					d) NODEPS=1 ;;
					e) NOEXTRACT=1 ;;
					f) FORCE=1 ;;
					g) GENSHA1=1 ;;
					G) GENMD5=1 ;;
					h)
						usage
						exit 0
						;;
					i) INSTALL=1 ;;
					j) export MAKEFLAGS="-j$OPTARG" ;;
					k) LOGGING=1 ;;
					l) DOWNLOAD="$OPTARG" ;;
					L) NOLASTMOD=1 ;;
					m) USE_COLOR="n" ;;
					n) NOSTRIP=1 ;;
					o) NOBUILD=1 ;;
					p) BUILDSCRIPT=$OPTARG ;;
					r) RMDEPS=1 ;;
					R) CHROOT=1 ;;
					s) DEP_BIN=1 ;;
					S) DEP_SUDO=1 ;;
					u) NOUP2DATE=1 ;;
					w) PKGDEST=$OPTARG ;;
					-)
						OPTIND=0
						break
						;;
					*)
						usage
						exit 1
						;;
				esac
			done
			;;
		*)
			true
			;;
	esac
	shift
done

# check for sudo
if [ "$DEP_SUDO" = "1" -a ! "`type -p sudo`" ]; then
	error "Cannot find the sudo binary!  Is sudo installed?"
	exit 1
fi

# convert a (possibly) relative path to absolute
cd $PKGDEST 2>/dev/null
if [ $? -ne 0 ]; then
	error "Package destination directory does not exist or permission denied."
	exit 1
fi
PKGDEST=`pwd`
cd $OLDPWD

if [ "$CLEANCACHE" = "1" ]; then
	if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
		msg "Cleaning up source files from the cache."
		rm -rf /var/cache/pacman/src/*
		chroot_clean
		exit 0
	else
		error "You must be root to clean the cache."
		exit 1
	fi
fi

unset pkgname pkgver pkgrel pkgdesc url license groups provides md5sums force
unset replaces depends removes conflicts backup source install makedepends
unset rodepends options
# some applications (eg, blackbox) will not build with some languages
unset LC_ALL LANG
umask 0022

# download buildscript if necessary
if [ ! -z "$DOWNLOAD" -a "$INFAKEROOT" != "1" ]; then
	msg "Retrieving $DOWNLOAD's buildscript..."
	
	# find the package
	if ! pacman -Si $DOWNLOAD >/dev/null 2>&1; then
		error "Package \"$DOWNLOAD\" was not found."
		exit 1
	fi
	
	# check for a download utility
	if [ -z "$FTPAGENT" ]; then
		error "FTPAGENT is not configured. Check the /etc/makepkg.conf file."
		msg "Aborting..."
		exit 1
	fi
	ftpclient=`echo $FTPAGENT | awk {'print $1'}`
	if [ ! -x $ftpclient ]; then
		error "ftpclient `basename $ftpclient` is not installed."
		msg "Aborting..."
		exit 1
	fi
	
	confs=`cat /etc/pacman.conf |grep ^Include|sed 's/.* = \(.*\)/\1/'`
	# TODO: -q option to download the src tarballs from Frugalware mirrros
	quickdl="_darcs/current/"
	
	# searching for a mirror
	repo=`pacman -Si $DOWNLOAD |grep ^Repo |sed -n 's/.* \([^ ]*\)/\1/;1 p'`
	dir=`grep ^Server /etc/pacman.d/$repo |sed -n 's/.* = \(.*\)/\1/;1 p'`
	arch=`grep ^Server /etc/pacman.d/$repo |sed -n 's/.*-\(.*\)/\1/;1 p'`
	cat=`pacman -Si $DOWNLOAD |grep ^G |sed 's/.* : \([^ ]*\) .*/\1/; s/-extra$//'`
	dlpath=`echo "$dir/../$quickdl"|sed "s|extra/frugalware-$CARCH/../$quickdl|${quickdl}extra/frugalware-$CARCH/../|"`
	
	# download the script
	mkdir $DOWNLOAD
	cd $DOWNLOAD
	# FIXME: apps other than wget maybe not support -m
	$FTPAGENT -m $dlpath/source/$cat/$DOWNLOAD/ 2>&1
	if [ ! -f $file ]; then
		error "Failed to download $file"
		msg "Aborting..."
		exit 1
	fi
	junk=`echo $dir|sed "s|^ftp://\(.*\)/frugalware-$arch|\1/$quickdl|;s|extra/$quickdl|${quickdl}extra/|"`/source/$cat/$DOWNLOAD/
	mv $junk* ./
	rm -rf `echo $junk|cut -d/ -f1`
	for i in `find * -type d`
	do
		( cd $i && [ -e .listing ] && rm .listing )
	done
fi

if [ ! -f $BUILDSCRIPT ]; then
	error "$BUILDSCRIPT does not exist."
	exit 1
fi

source $BUILDSCRIPT

# check for no-no's
if [ `echo $pkgver | grep '-'` ]; then
	error "pkgver is not allowed to contain hyphens."
	exit 1
fi
if [ `echo $pkgrel | grep '-'` ]; then
	error "pkgrel is not allowed to contain hyphens."
	exit 1
fi
if [ "$install" -a ! -f "$install" ]; then
	error "install scriptlet ($install) does not exist."
	exit 1
fi

if [ -f $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm -a "$FORCE" = "0" -a "$GENMD5" = "0" -a "$GENSHA1" = "0" ]; then
	if [ "$INSTALL" = "1" ]; then
		warning "a package has already been built, installing existing package."
		pacman --upgrade $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm
		exit $?
	else
		error "a package has already been built.  (use -f to overwrite)"
		exit 1
	fi
fi

# Generate the Changelog if necessary.
# in case we're in a darcs repo, but the current dir is not yet part of it
darcs add . >/dev/null 2>&1
if darcs --commands 2>&1|grep -q add && [ "$GENMD5" = "0" -a "$GENSHA1" = "0" ]; then
	if [ ! -e Changelog ] || [ `stat -c %Y Changelog` -lt `stat -c %Y $BUILDSCRIPT` ]; then
		msg "Generating the Changelog..."
		darcs changes $BUILDSCRIPT |sed "s|\(.*\)source/\(.*\)/FrugalBuild\(.*\)|\1\2\3|;/Can't find changes prior to:/,\$d" >Changelog
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %U:%G FrugalBuild` \
				Changelog
		fi
	fi
fi
# Build chroot environment if necessary.
if [ "$CHROOT" = "1" -a "$INCHROOT" != "1" ]; then
	if [ "`id -u`" != 0 ]; then
		error "Building in a chroot as an unprivileged user is not possible."
		exit 1
	fi
	if [ "$CHROOTDIR" = "" ]; then
		error "The CHROOTDIR environment variable is not defined."
		exit 1
	fi

	mkdir -p $CHROOTDIR/{dev,etc,proc,sys,var/cache/pacman,var/tmp/fst}

	if [ -e $CHROOTDIR/var/tmp/fst/lock ]; then
		error "Somebody already building in this chroot."
		plain "If you're sure makepkg is not already running, you"
		plain "can remove $CHROOTDIR/var/tmp/fst/lock."
		exit 1
	else
		touch $CHROOTDIR/var/tmp/fst/lock
	fi

	install -d -m 2775 {,$CHROOTDIR}/var/cache/ccache/$pkgname

	chroot_mount

	if [ ! -d "$CHROOTDIR/usr" ]; then
		msg "Building chroot environment"
		pacman -Syf $COREPKGS -r "$CHROOTDIR" --noconfirm
		if [ "$?" != "0" ]; then
			error "Failed to build chroot environment."
			chroot_umount
			msg "Removing lock file..."
			rm -f $CHROOTDIR/var/tmp/fst/lock
			exit 1
		fi
	else
		msg "Updating the chroot environment"
		# run pacman -Su twice in case pacman updated
		pacman -Syu -r "$CHROOTDIR" --noconfirm && \
			pacman -Su -r "$CHROOTDIR" --noconfirm
		if [ "$?" != "0" ]; then
			error "Failed to update chroot environment."
			chroot_umount
			msg "Removing lock file..."
			rm -f $CHROOTDIR/var/tmp/fst/lock
			exit 1
		fi
	fi
	# why is this necessary?
	chmod 1777 $CHROOTDIR/tmp
	
	msg "Copying config files to chroot"
	cp -pf /etc/makepkg.conf $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/resolv.conf $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/passwd $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/shadow $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/group $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/ld.so.conf $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/hosts $CHROOTDIR/etc > /dev/null &
	echo "fst ALL=(ALL)       NOPASSWD: ALL" >$CHROOTDIR/etc/sudoers
	cp -Ppf /etc/localtime $CHROOTDIR/etc >/dev/null &
	cp -pf /etc/services $CHROOTDIR/etc > /dev/null &
	if [ "$?" != "0" ]; then
		error "An error occurred while attempting to copy config files to chroot."
		chroot_umount
		exit 1
	fi
	# to make Finclude work
	if darcs --commands 2>&1|grep -q add; then
		[ -d $CHROOTDIR/var/tmp/fst/include/ ] || mkdir -p $CHROOTDIR/var/tmp/fst/include/
		if [ -d `darcs add . 2>&1|sed -n 's/[^/]*/../g; 4 p'`/source/include ]; then
			cp `darcs add . 2>&1|sed -n 's/[^/]*/../g; 4 p'`/source/include/* $CHROOTDIR/var/tmp/fst/include/
		elif [ -d $fst_root/$reponame/source/include ]; then
			cp $fst_root/$reponame/source/include/* $CHROOTDIR/var/tmp/fst/include/
		fi
	fi

	msg "Copying $pkgname's buildscript to chroot"
	cp -a * $CHROOTDIR/var/tmp/fst/
	chown -R fst:users $CHROOTDIR/var/tmp/fst
	
	if [ ! -x  /usr/sbin/chroot ]; then
		error "chroot was not found."
	else
		msg "Entering chroot environment"
		/usr/sbin/chroot $CHROOTDIR \
			/bin/su - fst -c "$0 --inchroot -S $ARGLIST"
	fi

	# save the build log if necessary
	if [ -f $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log ]; then
		mv $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log ./
	fi

	if [ -f $CHROOTDIR/var/tmp/fst/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm ]; then
		mv $CHROOTDIR/var/tmp/fst/*-${pkgver}-${pkgrel}-${CARCH}.fpm $PKGDEST
		if [ "`id -u`" = "0" ]; then
			chown `stat -c %U:%G FrugalBuild` \
				*-${pkgver}-${pkgrel}-${CARCH}.fpm
		fi
		# copy back the buildscript, maybe modified
		cp $CHROOTDIR/var/tmp/fst/FrugalBuild ./
		rm -rf $CHROOTDIR/var/tmp/fst/*
		chroot_clean
		ret=0
	else
		ret=1
	fi

	chroot_umount
	rm -f $CHROOTDIR/var/tmp/fst/lock
	exit $ret
fi

# Enter the fakeroot environment if necessary.  This will call the makepkg script again
# as the fake root user.  We detect this by passing a sentinel option (-F) to makepkg
if [ "`id -u`" != "0" ]; then
	if [ "$USE_FAKEROOT" = "y" -o "$USE_FAKEROOT" = "Y" ]; then
		if [ `type -p fakeroot` ]; then
			msg "Entering fakeroot environment"
			if [ "$INCHROOT" != "1" ]; then
				fakeroot -- $0 -F $ARGLIST
			else
				fakeroot -- $0 -F --inchroot $ARGLIST
			fi
			exit $?
		else
			warning "Fakeroot is not installed.  Building as an unprivileged user"
			plain "will result in non-root ownership of the packaged files."
			plain "Install the fakeroot package to correctly build as a non-root"
			plain "user."
			plain ""
			sleep 1
		fi
	else
		warning "Running makepkg as an unprivileged user will result in non-root"		
		plain "ownership of the packaged files.  Try using the fakeroot"
		plain "environment.  (USE_FAKEROOT=y in makepkg.conf)"
		plain ""
		sleep 1
	fi
fi

msg "Making package: $pkgname $pkgver-$pkgrel (`date`)"

unset deplist makedeplist
if [ `type -p pacman` -a "$NODEPS" = "0" ]; then
	msg "Checking Runtime Dependencies..."
	deplist=`checkdeps ${depends[@]}`
	handledeps $deplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
	msg "Checking Buildtime Dependencies..."
	makedeplist=`checkdeps ${makedepends[@]}`
	handledeps $makedeplist
	if [ $? -gt 0 ]; then
		exit 1
	fi
elif [ "$NODEPS" = "1" ]; then
	warning "skipping dependency checks."
else
	warning "pacman was not found in PATH. skipping dependency checks."
fi

cd $startdir

# version checking
if [ "$NOUP2DATE" = "0" ]; then
	msg "Checking for newer version..."
	if echo "$up2date"|grep -q " "; then
		cmd=`echo "$up2date"|sed 's/^\([^ ]*\) .*/\1/'`
		if type -p $cmd &>/dev/null; then
			up2date=`eval "$up2date"`
		else
			warning "The $cmd program is missing.  Cannot check for newer version!"
			up2date=""
			sleep 1
		fi
	fi
	if [ -z "$up2date" ]; then
		warning "Version checking informations are missing. Cannot check for newer version."
	else
		if [ "$pkgver" != "$up2date" ]; then
			echo "   FAILED" >&2
			error "Newer version available! ($pkgver < $up2date)"
			exit 1
		else
		echo "   Passed" >&2
		fi
	fi
fi

# estimate build time
if grep -i -q "^# Compiling Time: [~0-9\.]\+ SBU$" $BUILDSCRIPT && \
	[ ! -z "$SBU" ] && [ "$SBU" != "1" ]; then
	pkgsbu=`grep -i "^# Compiling time: [~0-9\.]\+ SBU$" $BUILDSCRIPT|sed 's/^# Compiling [Tt]ime: ~*\([0-9\.]\+\) SBU$/\1/'`
	secs=`echo "$pkgsbu*$SBU"|bc /dev/stdin|sed 's/\.[0-9]*$//'`
	if [ $secs -ge 3600 ]; then
		hrs=`echo $(($secs/3600))`
		secs=`echo $(($secs%3600))`
		mins=`echo $(($secs/60))`
		secs=`echo $(($secs%60))`
	elif [ $secs -ge 60 ]; then
		mins=`echo $(($secs/60))`
		secs=`echo $(($secs%60))`
	fi
	if [ ! -z "$hrs" ]; then
		[ $hrs -gt 1 ] && hrs="$hrs hours " || hrs="$hrs hour "
	fi
	if [ ! -z "$mins" ]; then
		[ $mins -gt 1 ] && mins="$mins minutes " || mins="$mins minute "
	fi
	if [ ! -z "$secs" ]; then
		[ $secs -gt 1 ] && secs="$secs seconds " || secs="$secs second "
	fi
	msg "Estimated build time: $hrs$mins$secs"
fi

# retrieve sources
msg "Retrieving Sources..."
mkdir -p src
cd $startdir/src
for netfile in ${source[@]}; do
	file=`strip_url $netfile`
	if [ -f ../$file ]; then
		msg "    Found $file in build dir"
		cp ../$file .
	elif [ -f /var/cache/pacman/src/$file ]; then
		msg "    Using local copy of $file"
		cp /var/cache/pacman/src/$file .
	else
		proto=`echo $netfile | sed 's|://.*||'`
		if [ "$proto" != "ftp" -a "$proto" != "http" -a "$proto" != "https" ]; then
			error "$netfile was not found in the build directory and is not a proper URL."
			msg "Aborting..."
			exit 1
		fi
		msg "    Downloading $file"
		$FTPAGENT $netfile 2>&1
		if [ ! -f $file ]; then
			error "Failed to download $file"
			msg "Aborting..."
			exit 1
		fi
		if [ "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
			mkdir -p /var/cache/pacman/src && cp $file /var/cache/pacman/src
		else
			cp $file ..
		fi
	fi
done

if [ "$GENMD5" = "0" -a "$GENSHA1" = "0" ]; then
	if [ "$NOEXTRACT" = "1" ]; then
		warning "Skipping source extraction       -- using existing src/ tree"
		warning "Skipping source integrity checks -- using existing src/ tree"
	else
		# SHA1 validation
		if [ ${#sha1sums[@]} -eq ${#source[@]} ]; then
			if [ `type -p sha1sum` ]; then
				msg "Validating source files with SHA1sums"
				errors=0
				idx=0
				for netfile in ${source[@]}; do
					file=`strip_url $netfile`
					echo -n "    $file ... " >&2
					echo "${sha1sums[$idx]}  $file" | sha1sum -c - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						echo "FAILED" >&2
						errors=1
					else
						echo "Passed" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The sha1sum program is missing.  Cannot verify source files!"
				sleep 1
			fi
		# MD5 validation
		elif [ ${#md5sums[@]} -eq ${#source[@]} ]; then
			if [ `type -p md5sum` ]; then
				msg "Validating source files with MD5sums"
				errors=0
				idx=0
				for netfile in ${source[@]}; do
					file=`strip_url $netfile`
					echo -n "    $file ... " >&2
					echo "${md5sums[$idx]}  $file" | md5sum -c - >/dev/null 2>&1
					if [ $? -ne 0 ]; then
						echo "FAILED" >&2
						errors=1
					else
						echo "Passed" >&2
					fi
					idx=$(($idx+1))
				done
				if [ $errors -gt 0 ]; then
					error "One or more files did not pass the validity check!"
					exit 1
				fi
			else
				warning "The md5sum program is missing.  Cannot verify source files!"
				sleep 1
			fi
		else
			warning "MD5sums and SHA1sums are missing or incomplete.  Cannot verify source integrity."
		fi

		# extract sources
		msg "Extracting Sources..."
		for netfile in ${source[@]}; do
			unziphack=0
			file=`strip_url $netfile`
			unset cmd
			case $file in
				*.tar.gz|*.tar.Z|*.tgz)
				cmd="tar --use-compress-program=gzip -xf $file" ;;
				*.tar.bz2|*.tbz2)
				cmd="tar --use-compress-program=bzip2 -xf $file" ;;
				*.tar)
				cmd="tar -xf $file" ;;
				*.zip)
				unziphack=1
				cmd="unzip -qqo $file" ;;
				*.gz)
				cmd="gunzip $file" ;;
				*.bz2)
				cmd="bunzip2 $file" ;;
			esac
			if [ "$cmd" != "" ]; then
				msg "    $cmd"
				$cmd
				if [ $? -ne 0 ]; then
					# unzip will return a 1 as a warning, it is not an error
					if [ "$unziphack" != "1" -o $? -ne 1 ]; then
						error "Failed to extract $file"
						msg "Aborting..."
						exit 1
					fi
				fi
			fi
		done
	fi
else
# generate md5 hashes
	if [ "$GENMD5" = "1" ]; then
		if [ ! `type -p md5sum` ]; then
			error "Cannot find the md5sum program."
			exit 1
	fi
		msg "Generating MD5sums for source files"
		plain ""
		ct=0
		newline=0
		numsrc=${#source[@]}
		for netfile in ${source[@]}; do
			file=`strip_url $netfile`
			sum=`md5sum $file | cut -d' ' -f 1`
			if [ $ct -eq 0 ]; then
				echo -n "md5sums=("
			else
				if [ $newline -eq 0 ]; then
					echo -n "         "
				fi
			fi
			echo -n "'$sum'"
			ct=$(($ct+1))
			if [ $ct -eq $numsrc ]; then
				echo ')'
			else
				if [ $newline -eq 1 ]; then
					echo '\'
					newline=0
				else
					echo -n ' '
					newline=1
				fi
			fi
		done
		plain ""
		exit 0
	# generate sha1 hashes
	elif [ "$GENSHA1" = "1" ]; then
		if [ ! `type -p sha1sum` ]; then
			error "Cannot find the sha1sum program."
			exit 1
		fi
		msg "Generating SHA1sums for source files"
		plain ""
		ct=0
		newline=0
		numsrc=${#source[@]}
		for netfile in ${source[@]}; do
			file=`strip_url $netfile`
			sum=`sha1sum $file | cut -d' ' -f 1`
			if [ $ct -eq 0 ]; then
				echo -n "sha1sums=("
			else
				echo -ne "\t  "
			fi
			echo -n "'$sum'"
			ct=$(($ct+1))
			if [ $ct -eq $numsrc ]; then
				echo ')'
			else
				echo ' \'
				newline=0
			fi
		done
	plain ""
	exit 0
    fi
fi

if [ "`id -u`" = "0" ]; then
	# chown all source files to root.root
	chown -R root.root $startdir/src
fi

# check for existing pkg directory
if [ -d $startdir/pkg ]; then
	msg "Removing existing pkg/ directory..."
	rm -rf $startdir/pkg
fi
mkdir -p $startdir/pkg

if [ "$NOBUILD" = "1" ]; then
	msg "Sources are ready."
	exit 0
fi

# use distcc if requested
if [ "$DISTCC" = "y" ]; then
	[ -d /usr/lib/distcc/bin ] && export PATH=/usr/lib/distcc/bin:$PATH
	if [ "$INCHROOT" = "1" ]; then
		[ -d /var/tmp/fst/.distcc ] || mkdir /var/tmp/fst/.distcc
		export DISTCC_DIR=/var/tmp/fst/.distcc
	fi
fi

# use ccache if it's available
if [ "$NOCCACHE" = "0" ]; then
	[ -d /usr/lib/ccache/bin ] && export PATH=/usr/lib/ccache/bin:$PATH
	install -d -m 2775 /var/cache/ccache/$pkgname
	export CCACHE_DIR=/var/cache/ccache/$pkgname
	export CCACHE_NOLINK=1
	export CCACHE_UMASK=002
fi

# build
msg "Starting build()..."
BUILDLOG=${startdir}/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.log
stime=`date +%s`
build 2>&1 | tee "${BUILDLOG}"
if [ ${PIPESTATUS[0]} -gt 0 ]; then
	error "Build Failed.  Aborting..."
	exit 2
fi

# count sbu
if [ "$SBU" == "1" ]; then
	# $SBU not yet set
	msg "Elapsed Time: $(($(date +%s)-$stime)) seconds"
elif [ ! -z "$SBU" ]; then
	if [ `type -p bc` ]; then
		msg "Elapsed Time: `echo -e "scale=2\n$(($(date +%s)-$stime))/$SBU"|bc /dev/stdin|sed 's/^\./0./'` SBU"
	else
		warning "The bc program is missing.  Cannot count SBU!"
	fi
fi

# documentation
msg "Preparing package documentation..."
cd $startdir
if [ -d pkg/usr/doc ]; then
	mkdir -p pkg/usr/share/doc
	cp -a pkg/usr/doc/* pkg/usr/share/doc/
	rm -rf pkg/usr/doc
fi
if [ ! "`check_option NODOCS`" -a "$NODOCS" = "0" ]; then
	mkdir -p pkg/usr/share/doc/$pkgname-$pkgver
	for i in `find src -maxdepth 2 -name ANNOUNCE -o -name AUTHORS -o -name *BUGS* -o -name CHANGES -o -name CONFIGURATION -o -name *COPYING* -o -name *COPYRIGHT* -o -name CREDITS -o -name ChangeLog -o -name Changelog -o -name CHANGELOG -o -name CONTRIBUTORS -o -name *FAQ* -o -name FEATURES -o -name FILES -o -name HACKING -o -name History -o -name HISTORY -o -name INSTALL* -o -name LICENSE -o -name LSM -o -name MANIFEST -o -name NEWS -o -name *README* -o -name *Readme* -o -name SITES -o -name *RELEASE* -o -name RELNOTES -o -name THANKS -o -name TIPS -o -name TODO -o -name VERSION -o -name CONFIGURATION* -o -name GPLLicense`
	do
		cp -a $i pkg/usr/share/doc/$pkgname-$pkgver/
	done
fi

# remove /usr/share/doc/$pkgname-$pkgver directory if empty
if [ -d pkg/usr/share/doc/$pkgname-$pkgver ]; then
	if [ -z "`ls -1 pkg/usr/share/doc/$pkgname-$pkgver`" ]; then
		rmdir pkg/usr/share/doc/$pkgname-$pkgver
	fi
fi

# remove /usr/share/doc/ directory if empty
if [ -d pkg/usr/share/doc ]; then
	if [ -z "`ls -1 pkg/usr/share/doc`" ]; then
		rmdir pkg/usr/share/doc
	fi
fi

# move /usr/share/info files to /usr/info
if [ -d pkg/usr/share/info ]; then
	mkdir -p pkg/usr/info
	cp -a pkg/usr/share/info/* pkg/usr/info/
	rm -rf pkg/usr/share/info
fi

# move /usr/share/man files to /usr/man
if [ -d pkg/usr/share/man ]; then
	mkdir -p pkg/usr/man 
	cp -a pkg/usr/share/man/* pkg/usr/man/
	rm -rf pkg/usr/share/man
fi

# remove /usr/share directory if empty
if [ -d pkg/usr/share ]; then
	if [ -z "`ls -1 pkg/usr/share`" ]; then
		rm -r pkg/usr/share
	fi
fi

# compress man pages
msg "Compressing man pages..."
find $startdir/pkg*/{usr{,/local,/share},opt/*}/man -type f 2>/dev/null | while read i ; do
	ext="${i##*.}"
	fn="${i##*/}"
	if [ "$ext" != "gz" -a "$ext" != "bz2" ]; then
		# update symlinks to this manpage
		find $startdir/pkg/{usr{,/local,/share},opt/*}/man -lname "$fn" 2> /dev/null | while read ln ; do
			rm -f "$ln"
			ln -sf "${fn}.gz" "${ln}.gz"
		done
		# compress the original
		gzip -9 "$i"
	fi
done

# strip binaries
if [ ! "`check_option NOSTRIP`" -a "$NOSTRIP" = "0" ]; then
	msg "Stripping debugging symbols from libraries..."
	find pkg*/{,usr,usr/local,opt/*}/lib -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip --strip-debug '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
	msg "Stripping symbols from binaries..."
	find pkg*/{,usr,usr/local,opt/*}/{bin,sbin} -type f -not -name "*.dll" -not -name "*.exe" \
		-exec /usr/bin/strip '{}' \; 2>&1 \
		| grep -v "No such file" | grep -v "format not recognized"
fi

# get some package meta info
builddate=`LC_ALL= ; LANG= ; date -u "+%a %b %e %H:%M:%S %Y"`
if [ "$PACKAGER" != "" ]; then
	packager="$PACKAGER"
else
	packager="Frugalware Linux (http://frugalware.org)"
fi

create_pkg $pkgname
if [ ! -z "$subpkgs" ]; then
	goodsubpkgs=1
	if [ "${#subdescs[@]}" != 0 ] && [ "${#subdescs[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#sublicense[@]}" != 0 ] && [ "${#sublicense[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subreplaces[@]}" != 0 ] && [ "${#subreplaces[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subgroups[@]}" != 0 ] && [ "${#subgroups[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subdepends[@]}" != 0 ] && [ "${#subdepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subrodepends[@]}" != 0 ] && [ "${#subrodepends[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subremoves[@]}" != 0 ] && [ "${#subremoves[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subconflicts[@]}" != 0 ] && [ "${#subconflicts[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subprovides[@]}" != 0 ] && [ "${#subprovides[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subbackup[@]}" != 0 ] && [ "${#subbackup[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ "${#subinstall[@]}" != 0 ] && [ "${#subinstall[@]}" != "${#subpkgs[@]}" ]; then
		goodsubpkgs=0
	fi
	if [ $goodsubpkgs -eq 1 ]; then
		i=0
		for subpkg in "${subpkgs[@]}"
		do
			unset pkgdesc license replaces groups depends rodepends removes conflicts provides backup install
			pkgdesc="${subdescs[$i]}"
			license="${sublicense[$i]}"
			replaces="${subreplaces[$i]}"
			groups="${subgroups[$i]}"
			depends="${subdepends[$i]}"
			rodepends="${subrodepends[$i]}"
			removes="${subremoves[$i]}"
			conflicts="${subconflicts[$i]}"
			provides="${subprovides[$i]}"
			backup="${subbackup[$i]}"
			install="${subinstall[$i]}"
			create_pkg $subpkg
			i=$(($i+1))
		done
	else
		warning "Subpackage infos are incomplete. Cannot create subpackages."
	fi
fi

cd $startdir
if [ "$CLEANUP" = "1" ]; then
	msg "Cleaning up..."
	rm -rf src pkg* filelist
fi

if [ "$RMDEPS" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" -a \( ! -z "$deplist" -o ! -z "$makedeplist" \) ]; then
	msg "Removing installed dependencies..."
	pacman -R $makedeplist $deplist
elif [ "$RMDEPS" = "1" -a "$DEP_SUDO" = "1" ]; then
	msg "Removing installed dependencies..."
	if [ "$INFAKEROOT" = "1" ]; then
		FAKEROOTKEY2=$FAKEROOTKEY
		unset FAKEROOTKEY
	fi
	sudo pacman -R $makedeplist $deplist
	if [ "$INFAKEROOT" = "1" ]; then
		export FAKEROOTKEY=$FAKEROOTKEY2
		unset FAKEROOTKEY2
	fi
fi

# check optimalization and write it to $BUILDSCRIPT
msg "Checking for optimalization..."
if grep -q -- "\($CFLAGS\|$CXXFLAGS\)" "${BUILDLOG}" ; then
	if ! grep -q "# optimalization" "${BUILDSCRIPT}" ; then
		echo -e "\n# optimalization OK" >> "${BUILDSCRIPT}"
	fi
else
	warning "This package isn't ${CARCH} optimized!"
fi

# remove build log
if [ "${LOGGING}" == "0" ] ; then
	msg "Removing build log..."
	rm -f "${BUILDLOG}"
fi

# update last mod line
if [ "$NOLASTMOD" = "0" ]; then
	sed -i "s/^\(# Last modified: \).*/\1`date -R`/i" $BUILDSCRIPT
fi

msg "Finished making: $pkgname  (`date`)"

if [ "$INSTALL" = "1" -a "`id -u`" = "0" -a "$INFAKEROOT" != "1" ]; then
	msg "Running pacman --upgrade..."
	pacman --upgrade $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm
	exit $?
elif [ "$INSTALL" = "1" -a "$DEP_SUDO" = "1" ]; then
	msg "Running pacman --upgrade..."
	if [ "$INFAKEROOT" = "1" ]; then
		FAKEROOTKEY2=$FAKEROOTKEY
		unset FAKEROOTKEY
	fi
	sudo pacman --upgrade $PKGDEST/${pkgname}-${pkgver}-${pkgrel}-${CARCH}.fpm
	if [ "$INFAKEROOT" = "1" ]; then
		export FAKEROOTKEY=$FAKEROOTKEY2
		unset FAKEROOTKEY2
	fi
fi

exit 0
